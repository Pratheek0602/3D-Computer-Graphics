/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Fri Aug 18 15:56:05 CEST 2023 ----! */
/* !---- C-Unit: CLImpl12_JNI.c, ../build/gensrc/native/jocl12/CLImpl12_JNI.c ----! */

#include <jni.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>

JavaVM* JVMUtil_GetJavaVM();
JNIEnv* JVMUtil_GetJNIEnv(int asDaemon, int* jvmAttached);
void JVMUtil_ReleaseJNIEnv(JNIEnv* env, int detachJVM);


static jobject JVMUtil_NewDirectByteBufferCopy(JNIEnv *env, jclass clazzBuffers, void * source_address, size_t capacity); /* forward decl. */

 #include <inttypes.h>
 #include <GL/glcorearb.h>
 #include <CL/cl.h>
 #include <CL/cl_ext.h>
 #include <CL/cl_gl.h>
  // Extern declarations of functions. The earliest version of OpenCL defines them, and the later versions use them.
  
  extern JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_dispatch_1clGetExtensionFunctionAddressStatic(JNIEnv *env, jclass _unused, jstring fname, jlong procAddress);
  
  extern JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clCreateContextFromType0(JNIEnv *env, jobject _unused, jobject props, jint props_byte_offset, jlong device_type, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress);
  
  extern JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clCreateContext0(JNIEnv *env, jobject _unused, jobject props, jint props_byte_offset, jint numDevices, jobject deviceList, jint device_type_offset, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress);
  
  extern JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clReleaseContextImpl(JNIEnv *env, jobject _unused, jlong context, jlong global, jlong procAddress);
  
  extern JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clBuildProgram0(JNIEnv *env, jobject _unused, jlong program, jint deviceCount, jobject deviceList, jint device_type_offset, jstring options, jobject cb, jlong procAddress);
  
  extern JNIEXPORT jobject JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clEnqueueMapImage0__JJIJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2I(JNIEnv *env, jobject _unused,
          jlong command_queue, jlong image, jint blocking_map, jlong map_flags,
          jobject origin, jint origin_byte_offset, jobject range, jint range_byte_offset,
          jobject image_row_pitch, jint image_row_pitch_byte_offset, jobject image_slice_pitch,
          jint image_slice_pitch_byte_offset, jint num_events_in_wait_list, jobject event_wait_list,
          jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset,
          jlong imageInfoAddress, jlong mapImageAddress);
  
  extern JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clSetEventCallback0(JNIEnv *env, jobject _unused, jlong event, jint trigger, jobject listener, jlong procAddress);
  
  extern JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl11_clSetMemObjectDestructorCallback0(JNIEnv *env, jobject _unused, jlong mem, jobject listener, jlong procAddress);
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetExtensionFunctionAddressStatic(JNIEnv *env, jclass _unused, jstring fname, jlong procAddress) {
    return Java_com_jogamp_opencl_llb_impl_CLImpl11_dispatch_1clGetExtensionFunctionAddressStatic(env, _unused, fname, procAddress);
  }
  
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clCreateContextFromType0(JNIEnv *env, jobject _unused, jobject props, jint props_byte_offset, jlong device_type, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clCreateContextFromType0(env, _unused, props, props_byte_offset, device_type, cb, global, errcode, errcode_byte_offset, procAddress);
  }
  
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clCreateContext0(JNIEnv *env, jobject _unused, jobject props, jint props_byte_offset, jint numDevices, jobject deviceList, jint device_type_offset, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clCreateContext0(env, _unused, props, props_byte_offset, numDevices, deviceList, device_type_offset, cb, global, errcode, errcode_byte_offset, procAddress);
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clReleaseContextImpl(JNIEnv *env, jobject _unused, jlong context, jlong global, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clReleaseContextImpl(env, _unused, context, global, procAddress);
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clBuildProgram0(JNIEnv *env, jobject _unused, jlong program, jint deviceCount, jobject deviceList, jint device_type_offset, jstring options, jobject cb, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clBuildProgram0(env, _unused, program, deviceCount, deviceList, device_type_offset, options, cb, procAddress);
  }
  
  JNIEXPORT jobject JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clEnqueueMapImage0__JJIJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2I(JNIEnv *env, jobject _unused,
          jlong command_queue, jlong image, jint blocking_map, jlong map_flags,
          jobject origin, jint origin_byte_offset, jobject range, jint range_byte_offset,
          jobject image_row_pitch, jint image_row_pitch_byte_offset, jobject image_slice_pitch,
          jint image_slice_pitch_byte_offset, jint num_events_in_wait_list, jobject event_wait_list,
          jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset,
          jlong imageInfoAddress, jlong mapImageAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clEnqueueMapImage0__JJIJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2I(env, _unused,
          command_queue, image, blocking_map, map_flags,
          origin, origin_byte_offset, range, range_byte_offset,
          image_row_pitch, image_row_pitch_byte_offset, image_slice_pitch,
          image_slice_pitch_byte_offset, num_events_in_wait_list, event_wait_list,
          event_wait_list_byte_offset, event, event_byte_offset, errcode_ret, errcode_ret_byte_offset,
          imageInfoAddress, mapImageAddress);
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clSetEventCallback0(JNIEnv *env, jobject _unused, jlong event, jint trigger, jobject listener, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clSetEventCallback0(env, _unused, event, trigger, listener, procAddress);
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl12_clSetMemObjectDestructorCallback0(JNIEnv *env, jobject _unused, jlong mem, jobject listener, jlong procAddress) {
      return Java_com_jogamp_opencl_llb_impl_CLImpl11_clSetMemObjectDestructorCallback0(env, _unused, mem, listener, procAddress);
  }

/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetPlatformIDs(int num_entries, com.jogamp.common.nio.PointerBuffer platforms, java.nio.IntBuffer num_platforms)
 *     C function: cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id *  platforms, cl_uint *  num_platforms)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetPlatformIDs0__ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint num_entries, jobject platforms, jint platforms_byte_offset, jobject num_platforms, jint num_platforms_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint num_entries, cl_platform_id *  platforms, cl_uint *  num_platforms);
  _local_ARG ptr_clGetPlatformIDs;
  cl_platform_id * _platforms_ptr = NULL;
  cl_uint * _num_platforms_ptr = NULL;
  cl_int _res;
    if ( NULL != platforms ) {
        _platforms_ptr = (cl_platform_id *) (((char*) (*env)->GetDirectBufferAddress(env, platforms)) + platforms_byte_offset);
    }

    if ( NULL != num_platforms ) {
        _num_platforms_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_platforms)) + num_platforms_byte_offset);
    }

  ptr_clGetPlatformIDs = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetPlatformIDs != NULL);
  _res = (cl_int) (* ptr_clGetPlatformIDs) ((cl_uint) num_entries, (cl_platform_id * ) _platforms_ptr, (cl_uint * ) _num_platforms_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetPlatformInfo(long platform, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetPlatformInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong platform, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetPlatformInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetPlatformInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetPlatformInfo != NULL);
  _res = (cl_int) (* ptr_clGetPlatformInfo) ((cl_platform_id) (intptr_t) platform, (cl_platform_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetDeviceIDs(long platform, long device_type, int num_entries, com.jogamp.common.nio.PointerBuffer devices, java.nio.IntBuffer num_devices)
 *     C function: cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *  devices, cl_uint *  num_devices)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetDeviceIDs0__JJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong platform, jlong device_type, jint num_entries, jobject devices, jint devices_byte_offset, jobject num_devices, jint num_devices_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *  devices, cl_uint *  num_devices);
  _local_ARG ptr_clGetDeviceIDs;
  cl_device_id * _devices_ptr = NULL;
  cl_uint * _num_devices_ptr = NULL;
  cl_int _res;
    if ( NULL != devices ) {
        _devices_ptr = (cl_device_id *) (((char*) (*env)->GetDirectBufferAddress(env, devices)) + devices_byte_offset);
    }

    if ( NULL != num_devices ) {
        _num_devices_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_devices)) + num_devices_byte_offset);
    }

  ptr_clGetDeviceIDs = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetDeviceIDs != NULL);
  _res = (cl_int) (* ptr_clGetDeviceIDs) ((cl_platform_id) (intptr_t) platform, (cl_device_type) device_type, (cl_uint) num_entries, (cl_device_id * ) _devices_ptr, (cl_uint * ) _num_devices_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetDeviceInfo(long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetDeviceInfo(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetDeviceInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetDeviceInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetDeviceInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetDeviceInfo != NULL);
  _res = (cl_int) (* ptr_clGetDeviceInfo) ((cl_device_id) (intptr_t) device, (cl_device_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clCreateSubDevices(long in_device, com.jogamp.common.nio.PointerBuffer properties, int num_devices, com.jogamp.common.nio.PointerBuffer out_devices, java.nio.IntBuffer num_devices_ret)
 *     C function: cl_int clCreateSubDevices(cl_device_id in_device, const cl_device_partition_property *  properties, cl_uint num_devices, cl_device_id *  out_devices, cl_uint *  num_devices_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateSubDevices1__JLjava_lang_Object_2IZILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong in_device, jobject properties, jint properties_byte_offset, jboolean properties_is_nio, jint num_devices, jobject out_devices, jint out_devices_byte_offset, jboolean out_devices_is_nio, jobject num_devices_ret, jint num_devices_ret_byte_offset, jboolean num_devices_ret_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id in_device, const cl_device_partition_property *  properties, cl_uint num_devices, cl_device_id *  out_devices, cl_uint *  num_devices_ret);
  _local_ARG ptr_clCreateSubDevices;
  cl_device_partition_property * _properties_ptr = NULL;
  cl_device_id * _out_devices_ptr = NULL;
  cl_uint * _num_devices_ret_ptr = NULL;
  cl_int _res;
  if ( NULL != properties ) {
    _properties_ptr = (cl_device_partition_property *) ( JNI_TRUE == properties_is_nio ?  (*env)->GetDirectBufferAddress(env, properties) :  (*env)->GetPrimitiveArrayCritical(env, properties, NULL) );  }
  if ( NULL != out_devices ) {
    _out_devices_ptr = (cl_device_id *) ( JNI_TRUE == out_devices_is_nio ?  (*env)->GetDirectBufferAddress(env, out_devices) :  (*env)->GetPrimitiveArrayCritical(env, out_devices, NULL) );  }
  if ( NULL != num_devices_ret ) {
    _num_devices_ret_ptr = (cl_uint *) ( JNI_TRUE == num_devices_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, num_devices_ret) :  (*env)->GetPrimitiveArrayCritical(env, num_devices_ret, NULL) );  }
  ptr_clCreateSubDevices = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSubDevices != NULL);
  _res = (cl_int) (* ptr_clCreateSubDevices) ((cl_device_id) (intptr_t) in_device, (const cl_device_partition_property * ) (((char *) _properties_ptr) + properties_byte_offset), (cl_uint) num_devices, (cl_device_id * ) (((char *) _out_devices_ptr) + out_devices_byte_offset), (cl_uint * ) (((char *) _num_devices_ret_ptr) + num_devices_ret_byte_offset));
  if ( JNI_FALSE == properties_is_nio && NULL != properties ) {
    (*env)->ReleasePrimitiveArrayCritical(env, properties, _properties_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == out_devices_is_nio && NULL != out_devices ) {
    (*env)->ReleasePrimitiveArrayCritical(env, out_devices, _out_devices_ptr, 0);  }
  if ( JNI_FALSE == num_devices_ret_is_nio && NULL != num_devices_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, num_devices_ret, _num_devices_ret_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainDevice(long device)
 *     C function: cl_int clRetainDevice(cl_device_id device)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainDevice1__JJ(JNIEnv *env, jobject _unused, jlong device, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id device);
  _local_ARG ptr_clRetainDevice;
  cl_int _res;
  ptr_clRetainDevice = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainDevice != NULL);
  _res = (cl_int) (* ptr_clRetainDevice) ((cl_device_id) (intptr_t) device);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseDevice(long device)
 *     C function: cl_int clReleaseDevice(cl_device_id device)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseDevice1__JJ(JNIEnv *env, jobject _unused, jlong device, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id device);
  _local_ARG ptr_clReleaseDevice;
  cl_int _res;
  ptr_clReleaseDevice = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseDevice != NULL);
  _res = (cl_int) (* ptr_clReleaseDevice) ((cl_device_id) (intptr_t) device);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainContext(long context)
 *     C function: cl_int clRetainContext(cl_context context)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainContext1__JJ(JNIEnv *env, jobject _unused, jlong context, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context);
  _local_ARG ptr_clRetainContext;
  cl_int _res;
  ptr_clRetainContext = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainContext != NULL);
  _res = (cl_int) (* ptr_clRetainContext) ((cl_context) (intptr_t) context);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetContextInfo(long context, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetContextInfo(cl_context context, cl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetContextInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context, cl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetContextInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetContextInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetContextInfo != NULL);
  _res = (cl_int) (* ptr_clGetContextInfo) ((cl_context) (intptr_t) context, (cl_context_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateCommandQueue(long context, long device, long properties, java.nio.IntBuffer errcode_ret)
 *     C function: cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateCommandQueue1__JJJLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong device, jlong properties, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_command_queue (CL_API_CALL*_local_ARG)(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateCommandQueue;
  cl_int * _errcode_ret_ptr = NULL;
  cl_command_queue _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateCommandQueue != NULL);
  _res = (cl_command_queue) (* ptr_clCreateCommandQueue) ((cl_context) (intptr_t) context, (cl_device_id) (intptr_t) device, (cl_command_queue_properties) properties, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainCommandQueue(long command_queue)
 *     C function: cl_int clRetainCommandQueue(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainCommandQueue1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clRetainCommandQueue;
  cl_int _res;
  ptr_clRetainCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainCommandQueue != NULL);
  _res = (cl_int) (* ptr_clRetainCommandQueue) ((cl_command_queue) (intptr_t) command_queue);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseCommandQueue(long command_queue)
 *     C function: cl_int clReleaseCommandQueue(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseCommandQueue1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clReleaseCommandQueue;
  cl_int _res;
  ptr_clReleaseCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseCommandQueue != NULL);
  _res = (cl_int) (* ptr_clReleaseCommandQueue) ((cl_command_queue) (intptr_t) command_queue);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetCommandQueueInfo(long command_queue, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetCommandQueueInfo(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetCommandQueueInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetCommandQueueInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetCommandQueueInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetCommandQueueInfo != NULL);
  _res = (cl_int) (* ptr_clGetCommandQueueInfo) ((cl_command_queue) (intptr_t) command_queue, (cl_command_queue_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateBuffer(long context, long flags, long size, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateBuffer1__JJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jlong size, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, size_t size, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateBuffer;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateBuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (size_t) size, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateSubBuffer(long buffer, long flags, int buffer_create_type, java.nio.Buffer buffer_create_info, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *  buffer_create_info, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateSubBuffer1__JJILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong buffer, jlong flags, jint buffer_create_type, jobject buffer_create_info, jint buffer_create_info_byte_offset, jboolean buffer_create_info_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *  buffer_create_info, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateSubBuffer;
  void * _buffer_create_info_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != buffer_create_info ) {
    _buffer_create_info_ptr = (void *) ( JNI_TRUE == buffer_create_info_is_nio ?  (*env)->GetDirectBufferAddress(env, buffer_create_info) :  (*env)->GetPrimitiveArrayCritical(env, buffer_create_info, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateSubBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSubBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateSubBuffer) ((cl_mem) (intptr_t) buffer, (cl_mem_flags) flags, (cl_buffer_create_type) buffer_create_type, (const void * ) (((char *) _buffer_create_info_ptr) + buffer_create_info_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == buffer_create_info_is_nio && NULL != buffer_create_info ) {
    (*env)->ReleasePrimitiveArrayCritical(env, buffer_create_info, _buffer_create_info_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateImage(long context, long flags, CLImageFormatImpl image_format, CLImageDescImpl image_desc, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateImage(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, const cl_image_desc *  image_desc, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateImage1__JJLjava_nio_ByteBuffer_2Ljava_nio_ByteBuffer_2Ljava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jobject image_format, jobject image_desc, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, const cl_image_desc *  image_desc, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateImage;
  cl_image_format * _image_format_ptr = NULL;
  cl_image_desc * _image_desc_ptr = NULL;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
    if ( NULL != image_format ) {
        _image_format_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_format)) + 0);
    }

    if ( NULL != image_desc ) {
        _image_desc_ptr = (cl_image_desc *) (((char*) (*env)->GetDirectBufferAddress(env, image_desc)) + 0);
    }

  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateImage != NULL);
  _res = (cl_mem) (* ptr_clCreateImage) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (const cl_image_format * ) _image_format_ptr, (const cl_image_desc * ) _image_desc_ptr, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainMemObject(long memobj)
 *     C function: cl_int clRetainMemObject(cl_mem memobj)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainMemObject1__JJ(JNIEnv *env, jobject _unused, jlong memobj, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj);
  _local_ARG ptr_clRetainMemObject;
  cl_int _res;
  ptr_clRetainMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainMemObject != NULL);
  _res = (cl_int) (* ptr_clRetainMemObject) ((cl_mem) (intptr_t) memobj);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseMemObject(long memobj)
 *     C function: cl_int clReleaseMemObject(cl_mem memobj)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseMemObject1__JJ(JNIEnv *env, jobject _unused, jlong memobj, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj);
  _local_ARG ptr_clReleaseMemObject;
  cl_int _res;
  ptr_clReleaseMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseMemObject != NULL);
  _res = (cl_int) (* ptr_clReleaseMemObject) ((cl_mem) (intptr_t) memobj);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetSupportedImageFormats(long context, long flags, int image_type, int num_entries, CLImageFormatImpl image_formats, java.nio.IntBuffer num_image_formats)
 *     C function: cl_int clGetSupportedImageFormats(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *  image_formats, cl_uint *  num_image_formats)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetSupportedImageFormats1__JJIILjava_nio_ByteBuffer_2Ljava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint image_type, jint num_entries, jobject image_formats, jobject num_image_formats, jint num_image_formats_byte_offset, jboolean num_image_formats_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *  image_formats, cl_uint *  num_image_formats);
  _local_ARG ptr_clGetSupportedImageFormats;
  cl_image_format * _image_formats_ptr = NULL;
  cl_uint * _num_image_formats_ptr = NULL;
  cl_int _res;
    if ( NULL != image_formats ) {
        _image_formats_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_formats)) + 0);
    }

  if ( NULL != num_image_formats ) {
    _num_image_formats_ptr = (cl_uint *) ( JNI_TRUE == num_image_formats_is_nio ?  (*env)->GetDirectBufferAddress(env, num_image_formats) :  (*env)->GetPrimitiveArrayCritical(env, num_image_formats, NULL) );  }
  ptr_clGetSupportedImageFormats = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetSupportedImageFormats != NULL);
  _res = (cl_int) (* ptr_clGetSupportedImageFormats) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_mem_object_type) image_type, (cl_uint) num_entries, (cl_image_format * ) _image_formats_ptr, (cl_uint * ) (((char *) _num_image_formats_ptr) + num_image_formats_byte_offset));
  if ( JNI_FALSE == num_image_formats_is_nio && NULL != num_image_formats ) {
    (*env)->ReleasePrimitiveArrayCritical(env, num_image_formats, _num_image_formats_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetMemObjectInfo(long memobj, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetMemObjectInfo(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetMemObjectInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong memobj, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetMemObjectInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetMemObjectInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetMemObjectInfo != NULL);
  _res = (cl_int) (* ptr_clGetMemObjectInfo) ((cl_mem) (intptr_t) memobj, (cl_mem_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetImageInfo(long image, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetImageInfo(cl_mem image, cl_image_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetImageInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong image, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem image, cl_image_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetImageInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetImageInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetImageInfo != NULL);
  _res = (cl_int) (* ptr_clGetImageInfo) ((cl_mem) (intptr_t) image, (cl_image_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateSampler(long context, int normalized_coords, int addressing_mode, int filter_mode, java.nio.IntBuffer errcode_ret)
 *     C function: cl_sampler clCreateSampler(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateSampler1__JIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jint normalized_coords, jint addressing_mode, jint filter_mode, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_sampler (CL_API_CALL*_local_ARG)(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateSampler;
  cl_int * _errcode_ret_ptr = NULL;
  cl_sampler _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSampler != NULL);
  _res = (cl_sampler) (* ptr_clCreateSampler) ((cl_context) (intptr_t) context, (cl_bool) normalized_coords, (cl_addressing_mode) addressing_mode, (cl_filter_mode) filter_mode, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainSampler(long sampler)
 *     C function: cl_int clRetainSampler(cl_sampler sampler)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainSampler1__JJ(JNIEnv *env, jobject _unused, jlong sampler, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler);
  _local_ARG ptr_clRetainSampler;
  cl_int _res;
  ptr_clRetainSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainSampler != NULL);
  _res = (cl_int) (* ptr_clRetainSampler) ((cl_sampler) (intptr_t) sampler);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseSampler(long sampler)
 *     C function: cl_int clReleaseSampler(cl_sampler sampler)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseSampler1__JJ(JNIEnv *env, jobject _unused, jlong sampler, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler);
  _local_ARG ptr_clReleaseSampler;
  cl_int _res;
  ptr_clReleaseSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseSampler != NULL);
  _res = (cl_int) (* ptr_clReleaseSampler) ((cl_sampler) (intptr_t) sampler);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetSamplerInfo(long sampler, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetSamplerInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong sampler, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetSamplerInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetSamplerInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetSamplerInfo != NULL);
  _res = (cl_int) (* ptr_clGetSamplerInfo) ((cl_sampler) (intptr_t) sampler, (cl_sampler_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateProgramWithSource(long context, int count, java.lang.String[] strings, com.jogamp.common.nio.PointerBuffer lengths, java.nio.IntBuffer errcode_ret)
 *     C function: cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char *  *  strings, const size_t *  lengths, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateProgramWithSource0__JI_3Ljava_lang_String_2Ljava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint count, jobjectArray /*elements are String*/ strings, jobject lengths, jint lengths_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef cl_program (CL_API_CALL*_local_ARG)(cl_context context, cl_uint count, const char *  *  strings, const size_t *  lengths, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateProgramWithSource;
  const char * * _strings_ptr_copy = NULL; /* copy of data in strings, laid out according to C memory model */
  jobject _tmpObj;
  int _copyIndex;
  jsize _tmpArrayLen;
  size_t * _lengths_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_program _res;
  if ( NULL != strings ) {

    /* Copy contents of strings into _strings_ptr_copy */
    _tmpArrayLen = (*env)->GetArrayLength(env, strings);
    _strings_ptr_copy = (const char * *) malloc(_tmpArrayLen * sizeof(char *));
  if ( NULL == _strings_ptr_copy ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Could not allocate buffer for copying data in argument \"strings\" in native dispatcher for \"clCreateProgramWithSource\"");
      return 0;
    }
    for (_copyIndex = 0; _copyIndex < _tmpArrayLen; ++_copyIndex) {
      /* get each element of the array argument "strings" */
      _tmpObj = (*env)->GetObjectArrayElement(env, strings, _copyIndex);
    if ( NULL != (jstring) _tmpObj ) {
    _strings_ptr_copy[_copyIndex] = (*env)->GetStringUTFChars(env, (jstring) _tmpObj, (jboolean*)NULL);
  if ( NULL == _strings_ptr_copy[_copyIndex] ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Failed to get UTF-8 chars for argument \"(jstring) _tmpObj\" in native dispatcher for \"clCreateProgramWithSource\"");
      return 0;
    }
  } else {      _strings_ptr_copy[_copyIndex] = NULL;
  }
    }

  }
    if ( NULL != lengths ) {
        _lengths_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, lengths)) + lengths_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clCreateProgramWithSource = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateProgramWithSource != NULL);
  _res = (cl_program) (* ptr_clCreateProgramWithSource) ((cl_context) (intptr_t) context, (cl_uint) count, (const char *  * ) _strings_ptr_copy, (const size_t * ) _lengths_ptr, (cl_int * ) _errcode_ret_ptr);
  if ( NULL != strings ) {
    /* Clean up _strings_ptr_copy */
    _tmpArrayLen = (*env)->GetArrayLength(env, strings);
    for (_copyIndex = 0; _copyIndex < _tmpArrayLen; ++_copyIndex) {
      /* free each element of _strings_ptr_copy */
      _tmpObj = (*env)->GetObjectArrayElement(env, strings, _copyIndex);
     (*env)->ReleaseStringUTFChars(env, (jstring) _tmpObj, _strings_ptr_copy[_copyIndex]);
    }
    free((void*) _strings_ptr_copy);
  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateProgramWithBinary(long context, int num_devices, com.jogamp.common.nio.PointerBuffer device_list, com.jogamp.common.nio.PointerBuffer lengths, com.jogamp.common.nio.PointerBuffer binaries, java.nio.IntBuffer binary_status, java.nio.IntBuffer errcode_ret)
 *     C function: cl_program clCreateProgramWithBinary(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const size_t *  lengths, unsigned const char *  *  binaries, cl_int *  binary_status, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateProgramWithBinary0__JILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint num_devices, jobject device_list, jint device_list_byte_offset, jobject lengths, jint lengths_byte_offset, jobject binaries, jint binaries_byte_offset, jobject binary_status, jint binary_status_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef cl_program (CL_API_CALL*_local_ARG)(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const size_t *  lengths, unsigned const char *  *  binaries, cl_int *  binary_status, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateProgramWithBinary;
  cl_device_id * _device_list_ptr = NULL;
  size_t * _lengths_ptr = NULL;
  unsigned char * * _binaries_ptr = NULL;
  cl_int * _binary_status_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_program _res;
    if ( NULL != device_list ) {
        _device_list_ptr = (cl_device_id *) (((char*) (*env)->GetDirectBufferAddress(env, device_list)) + device_list_byte_offset);
    }

    if ( NULL != lengths ) {
        _lengths_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, lengths)) + lengths_byte_offset);
    }

    if ( NULL != binaries ) {
        _binaries_ptr = (unsigned char * *) (((char*) (*env)->GetDirectBufferAddress(env, binaries)) + binaries_byte_offset);
    }

    if ( NULL != binary_status ) {
        _binary_status_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, binary_status)) + binary_status_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clCreateProgramWithBinary = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateProgramWithBinary != NULL);
  _res = (cl_program) (* ptr_clCreateProgramWithBinary) ((cl_context) (intptr_t) context, (cl_uint) num_devices, (const cl_device_id * ) _device_list_ptr, (const size_t * ) _lengths_ptr, (unsigned const char *  * ) _binaries_ptr, (cl_int * ) _binary_status_ptr, (cl_int * ) _errcode_ret_ptr);
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateProgramWithBuiltInKernels(long context, int num_devices, com.jogamp.common.nio.PointerBuffer device_list, java.nio.ByteBuffer kernel_names, java.nio.IntBuffer errcode_ret)
 *     C function: cl_program clCreateProgramWithBuiltInKernels(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const char *  kernel_names, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateProgramWithBuiltInKernels1__JILjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jint num_devices, jobject device_list, jint device_list_byte_offset, jboolean device_list_is_nio, jobject kernel_names, jint kernel_names_byte_offset, jboolean kernel_names_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_program (CL_API_CALL*_local_ARG)(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const char *  kernel_names, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateProgramWithBuiltInKernels;
  cl_device_id * _device_list_ptr = NULL;
  char * _kernel_names_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_program _res;
  if ( NULL != device_list ) {
    _device_list_ptr = (cl_device_id *) ( JNI_TRUE == device_list_is_nio ?  (*env)->GetDirectBufferAddress(env, device_list) :  (*env)->GetPrimitiveArrayCritical(env, device_list, NULL) );  }
  if ( NULL != kernel_names ) {
    _kernel_names_ptr = (char *) ( JNI_TRUE == kernel_names_is_nio ?  (*env)->GetDirectBufferAddress(env, kernel_names) :  (*env)->GetPrimitiveArrayCritical(env, kernel_names, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateProgramWithBuiltInKernels = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateProgramWithBuiltInKernels != NULL);
  _res = (cl_program) (* ptr_clCreateProgramWithBuiltInKernels) ((cl_context) (intptr_t) context, (cl_uint) num_devices, (const cl_device_id * ) (((char *) _device_list_ptr) + device_list_byte_offset), (const char * ) (((char *) _kernel_names_ptr) + kernel_names_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == device_list_is_nio && NULL != device_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, device_list, _device_list_ptr, 0);  }
  if ( JNI_FALSE == kernel_names_is_nio && NULL != kernel_names ) {
    (*env)->ReleasePrimitiveArrayCritical(env, kernel_names, _kernel_names_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainProgram(long program)
 *     C function: cl_int clRetainProgram(cl_program program)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainProgram1__JJ(JNIEnv *env, jobject _unused, jlong program, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program);
  _local_ARG ptr_clRetainProgram;
  cl_int _res;
  ptr_clRetainProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainProgram != NULL);
  _res = (cl_int) (* ptr_clRetainProgram) ((cl_program) (intptr_t) program);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseProgram(long program)
 *     C function: cl_int clReleaseProgram(cl_program program)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseProgram1__JJ(JNIEnv *env, jobject _unused, jlong program, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program);
  _local_ARG ptr_clReleaseProgram;
  cl_int _res;
  ptr_clReleaseProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseProgram != NULL);
  _res = (cl_int) (* ptr_clReleaseProgram) ((cl_program) (intptr_t) program);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clUnloadPlatformCompiler(long platform)
 *     C function: cl_int clUnloadPlatformCompiler(cl_platform_id platform)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clUnloadPlatformCompiler1__JJ(JNIEnv *env, jobject _unused, jlong platform, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_platform_id platform);
  _local_ARG ptr_clUnloadPlatformCompiler;
  cl_int _res;
  ptr_clUnloadPlatformCompiler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clUnloadPlatformCompiler != NULL);
  _res = (cl_int) (* ptr_clUnloadPlatformCompiler) ((cl_platform_id) (intptr_t) platform);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetProgramInfo(long program, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetProgramInfo(cl_program program, cl_program_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetProgramInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_program_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetProgramInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetProgramInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetProgramInfo != NULL);
  _res = (cl_int) (* ptr_clGetProgramInfo) ((cl_program) (intptr_t) program, (cl_program_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetProgramBuildInfo(long program, long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetProgramBuildInfo(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetProgramBuildInfo0__JJIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetProgramBuildInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetProgramBuildInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetProgramBuildInfo != NULL);
  _res = (cl_int) (* ptr_clGetProgramBuildInfo) ((cl_program) (intptr_t) program, (cl_device_id) (intptr_t) device, (cl_program_build_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateKernel(long program, java.lang.String kernel_name, java.nio.IntBuffer errcode_ret)
 *     C function: cl_kernel clCreateKernel(cl_program program, const char *  kernel_name, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateKernel1__JLjava_lang_String_2Ljava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong program, jstring kernel_name, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_kernel (CL_API_CALL*_local_ARG)(cl_program program, const char *  kernel_name, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateKernel;
  const char* _strchars_kernel_name = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_kernel _res;
  if ( NULL != kernel_name ) {
    _strchars_kernel_name = (*env)->GetStringUTFChars(env, kernel_name, (jboolean*)NULL);
  if ( NULL == _strchars_kernel_name ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Failed to get UTF-8 chars for argument \"kernel_name\" in native dispatcher for \"clCreateKernel\"");
      return 0;
    }
  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateKernel != NULL);
  _res = (cl_kernel) (* ptr_clCreateKernel) ((cl_program) (intptr_t) program, (const char * ) _strchars_kernel_name, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( NULL != kernel_name ) {
    (*env)->ReleaseStringUTFChars(env, kernel_name, _strchars_kernel_name);
  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clCreateKernelsInProgram(long program, int num_kernels, com.jogamp.common.nio.PointerBuffer kernels, java.nio.IntBuffer num_kernels_ret)
 *     C function: cl_int clCreateKernelsInProgram(cl_program program, cl_uint num_kernels, cl_kernel *  kernels, cl_uint *  num_kernels_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateKernelsInProgram0__JILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jint num_kernels, jobject kernels, jint kernels_byte_offset, jobject num_kernels_ret, jint num_kernels_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_uint num_kernels, cl_kernel *  kernels, cl_uint *  num_kernels_ret);
  _local_ARG ptr_clCreateKernelsInProgram;
  cl_kernel * _kernels_ptr = NULL;
  cl_uint * _num_kernels_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != kernels ) {
        _kernels_ptr = (cl_kernel *) (((char*) (*env)->GetDirectBufferAddress(env, kernels)) + kernels_byte_offset);
    }

    if ( NULL != num_kernels_ret ) {
        _num_kernels_ret_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_kernels_ret)) + num_kernels_ret_byte_offset);
    }

  ptr_clCreateKernelsInProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateKernelsInProgram != NULL);
  _res = (cl_int) (* ptr_clCreateKernelsInProgram) ((cl_program) (intptr_t) program, (cl_uint) num_kernels, (cl_kernel * ) _kernels_ptr, (cl_uint * ) _num_kernels_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainKernel(long kernel)
 *     C function: cl_int clRetainKernel(cl_kernel kernel)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainKernel1__JJ(JNIEnv *env, jobject _unused, jlong kernel, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel);
  _local_ARG ptr_clRetainKernel;
  cl_int _res;
  ptr_clRetainKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainKernel != NULL);
  _res = (cl_int) (* ptr_clRetainKernel) ((cl_kernel) (intptr_t) kernel);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseKernel(long kernel)
 *     C function: cl_int clReleaseKernel(cl_kernel kernel)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseKernel1__JJ(JNIEnv *env, jobject _unused, jlong kernel, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel);
  _local_ARG ptr_clReleaseKernel;
  cl_int _res;
  ptr_clReleaseKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseKernel != NULL);
  _res = (cl_int) (* ptr_clReleaseKernel) ((cl_kernel) (intptr_t) kernel);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clSetKernelArg(long kernel, int arg_index, long arg_size, java.nio.Buffer arg_value)
 *     C function: cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *  arg_value)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clSetKernelArg0__JIJLjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jint arg_index, jlong arg_size, jobject arg_value, jint arg_value_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *  arg_value);
  _local_ARG ptr_clSetKernelArg;
  void * _arg_value_ptr = NULL;
  cl_int _res;
    if ( NULL != arg_value ) {
        _arg_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, arg_value)) + arg_value_byte_offset);
    }

  ptr_clSetKernelArg = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clSetKernelArg != NULL);
  _res = (cl_int) (* ptr_clSetKernelArg) ((cl_kernel) (intptr_t) kernel, (cl_uint) arg_index, (size_t) arg_size, (const void * ) _arg_value_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetKernelInfo(long kernel, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetKernelInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetKernelInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetKernelInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetKernelInfo != NULL);
  _res = (cl_int) (* ptr_clGetKernelInfo) ((cl_kernel) (intptr_t) kernel, (cl_kernel_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetKernelArgInfo(long kernel, int arg_indx, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetKernelArgInfo1__JIIJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong kernel, jint arg_indx, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jboolean param_value_is_nio, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jboolean param_value_size_ret_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetKernelArgInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
  if ( NULL != param_value ) {
    _param_value_ptr = (void *) ( JNI_TRUE == param_value_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value) :  (*env)->GetPrimitiveArrayCritical(env, param_value, NULL) );  }
  if ( NULL != param_value_size_ret ) {
    _param_value_size_ret_ptr = (size_t *) ( JNI_TRUE == param_value_size_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value_size_ret) :  (*env)->GetPrimitiveArrayCritical(env, param_value_size_ret, NULL) );  }
  ptr_clGetKernelArgInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetKernelArgInfo != NULL);
  _res = (cl_int) (* ptr_clGetKernelArgInfo) ((cl_kernel) (intptr_t) kernel, (cl_uint) arg_indx, (cl_kernel_arg_info) param_name, (size_t) param_value_size, (void * ) (((char *) _param_value_ptr) + param_value_byte_offset), (size_t * ) (((char *) _param_value_size_ret_ptr) + param_value_size_ret_byte_offset));
  if ( JNI_FALSE == param_value_is_nio && NULL != param_value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value, _param_value_ptr, 0);  }
  if ( JNI_FALSE == param_value_size_ret_is_nio && NULL != param_value_size_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value_size_ret, _param_value_size_ret_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetKernelWorkGroupInfo(long kernel, long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetKernelWorkGroupInfo0__JJIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetKernelWorkGroupInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetKernelWorkGroupInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetKernelWorkGroupInfo != NULL);
  _res = (cl_int) (* ptr_clGetKernelWorkGroupInfo) ((cl_kernel) (intptr_t) kernel, (cl_device_id) (intptr_t) device, (cl_kernel_work_group_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clWaitForEvents(int num_events, com.jogamp.common.nio.PointerBuffer event_list)
 *     C function: cl_int clWaitForEvents(cl_uint num_events, const cl_event *  event_list)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clWaitForEvents0__ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint num_events, jobject event_list, jint event_list_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint num_events, const cl_event *  event_list);
  _local_ARG ptr_clWaitForEvents;
  cl_event * _event_list_ptr = NULL;
  cl_int _res;
    if ( NULL != event_list ) {
        _event_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_list)) + event_list_byte_offset);
    }

  ptr_clWaitForEvents = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clWaitForEvents != NULL);
  _res = (cl_int) (* ptr_clWaitForEvents) ((cl_uint) num_events, (const cl_event * ) _event_list_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetEventInfo(long event, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetEventInfo(cl_event event, cl_event_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetEventInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong event, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_event_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetEventInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetEventInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetEventInfo != NULL);
  _res = (cl_int) (* ptr_clGetEventInfo) ((cl_event) (intptr_t) event, (cl_event_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateUserEvent(long context, java.nio.IntBuffer errcode_ret)
 *     C function: cl_event clCreateUserEvent(cl_context context, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateUserEvent1__JLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_event (CL_API_CALL*_local_ARG)(cl_context context, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateUserEvent;
  cl_int * _errcode_ret_ptr = NULL;
  cl_event _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateUserEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateUserEvent != NULL);
  _res = (cl_event) (* ptr_clCreateUserEvent) ((cl_context) (intptr_t) context, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainEvent(long event)
 *     C function: cl_int clRetainEvent(cl_event event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainEvent1__JJ(JNIEnv *env, jobject _unused, jlong event, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event);
  _local_ARG ptr_clRetainEvent;
  cl_int _res;
  ptr_clRetainEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainEvent != NULL);
  _res = (cl_int) (* ptr_clRetainEvent) ((cl_event) (intptr_t) event);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseEvent(long event)
 *     C function: cl_int clReleaseEvent(cl_event event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseEvent1__JJ(JNIEnv *env, jobject _unused, jlong event, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event);
  _local_ARG ptr_clReleaseEvent;
  cl_int _res;
  ptr_clReleaseEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseEvent != NULL);
  _res = (cl_int) (* ptr_clReleaseEvent) ((cl_event) (intptr_t) event);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clSetUserEventStatus(long event, int execution_status)
 *     C function: cl_int clSetUserEventStatus(cl_event event, cl_int execution_status)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clSetUserEventStatus1__JIJ(JNIEnv *env, jobject _unused, jlong event, jint execution_status, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_int execution_status);
  _local_ARG ptr_clSetUserEventStatus;
  cl_int _res;
  ptr_clSetUserEventStatus = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clSetUserEventStatus != NULL);
  _res = (cl_int) (* ptr_clSetUserEventStatus) ((cl_event) (intptr_t) event, (cl_int) execution_status);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetEventProfilingInfo(long event, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetEventProfilingInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong event, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetEventProfilingInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetEventProfilingInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetEventProfilingInfo != NULL);
  _res = (cl_int) (* ptr_clGetEventProfilingInfo) ((cl_event) (intptr_t) event, (cl_profiling_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clFlush(long command_queue)
 *     C function: cl_int clFlush(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clFlush1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clFlush;
  cl_int _res;
  ptr_clFlush = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clFlush != NULL);
  _res = (cl_int) (* ptr_clFlush) ((cl_command_queue) (intptr_t) command_queue);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clFinish(long command_queue)
 *     C function: cl_int clFinish(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clFinish1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clFinish;
  cl_int _res;
  ptr_clFinish = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clFinish != NULL);
  _res = (cl_int) (* ptr_clFinish) ((cl_command_queue) (intptr_t) command_queue);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueReadBuffer(long command_queue, long buffer, int blocking_read, long offset, long size, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t size, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueReadBuffer0__JJIJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_read, jlong offset, jlong size, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t size, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadBuffer;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_read, (size_t) offset, (size_t) size, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueReadBufferRect(long command_queue, long buffer, int blocking_read, com.jogamp.common.nio.PointerBuffer buffer_offset, com.jogamp.common.nio.PointerBuffer host_offset, com.jogamp.common.nio.PointerBuffer region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *  buffer_offset, const size_t *  host_offset, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueReadBufferRect0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_read, jobject buffer_offset, jint buffer_offset_byte_offset, jobject host_offset, jint host_offset_byte_offset, jobject region, jint region_byte_offset, jlong buffer_row_pitch, jlong buffer_slice_pitch, jlong host_row_pitch, jlong host_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *  buffer_offset, const size_t *  host_offset, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadBufferRect;
  size_t * _buffer_offset_ptr = NULL;
  size_t * _host_offset_ptr = NULL;
  size_t * _region_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != buffer_offset ) {
        _buffer_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, buffer_offset)) + buffer_offset_byte_offset);
    }

    if ( NULL != host_offset ) {
        _host_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, host_offset)) + host_offset_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_read, (const size_t * ) _buffer_offset_ptr, (const size_t * ) _host_offset_ptr, (const size_t * ) _region_ptr, (size_t) buffer_row_pitch, (size_t) buffer_slice_pitch, (size_t) host_row_pitch, (size_t) host_slice_pitch, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueWriteBuffer(long command_queue, long buffer, int blocking_write, long offset, long size, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t size, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueWriteBuffer0__JJIJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_write, jlong offset, jlong size, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t size, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteBuffer;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_write, (size_t) offset, (size_t) size, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueWriteBufferRect(long command_queue, long buffer, int blocking_write, com.jogamp.common.nio.PointerBuffer buffer_offset, com.jogamp.common.nio.PointerBuffer host_offset, com.jogamp.common.nio.PointerBuffer region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *  buffer_offset, const size_t *  host_offset, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueWriteBufferRect0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_write, jobject buffer_offset, jint buffer_offset_byte_offset, jobject host_offset, jint host_offset_byte_offset, jobject region, jint region_byte_offset, jlong buffer_row_pitch, jlong buffer_slice_pitch, jlong host_row_pitch, jlong host_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *  buffer_offset, const size_t *  host_offset, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteBufferRect;
  size_t * _buffer_offset_ptr = NULL;
  size_t * _host_offset_ptr = NULL;
  size_t * _region_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != buffer_offset ) {
        _buffer_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, buffer_offset)) + buffer_offset_byte_offset);
    }

    if ( NULL != host_offset ) {
        _host_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, host_offset)) + host_offset_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_write, (const size_t * ) _buffer_offset_ptr, (const size_t * ) _host_offset_ptr, (const size_t * ) _region_ptr, (size_t) buffer_row_pitch, (size_t) buffer_slice_pitch, (size_t) host_row_pitch, (size_t) host_slice_pitch, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueFillBuffer(long command_queue, long buffer, java.nio.Buffer pattern, long pattern_size, long offset, long size, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void *  pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueFillBuffer1__JJLjava_lang_Object_2IZJJJILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jobject pattern, jint pattern_byte_offset, jboolean pattern_is_nio, jlong pattern_size, jlong offset, jlong size, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jboolean event_wait_list_is_nio, jobject event, jint event_byte_offset, jboolean event_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, const void *  pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueFillBuffer;
  void * _pattern_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
  if ( NULL != pattern ) {
    _pattern_ptr = (void *) ( JNI_TRUE == pattern_is_nio ?  (*env)->GetDirectBufferAddress(env, pattern) :  (*env)->GetPrimitiveArrayCritical(env, pattern, NULL) );  }
  if ( NULL != event_wait_list ) {
    _event_wait_list_ptr = (cl_event *) ( JNI_TRUE == event_wait_list_is_nio ?  (*env)->GetDirectBufferAddress(env, event_wait_list) :  (*env)->GetPrimitiveArrayCritical(env, event_wait_list, NULL) );  }
  if ( NULL != event ) {
    _event_ptr = (cl_event *) ( JNI_TRUE == event_is_nio ?  (*env)->GetDirectBufferAddress(env, event) :  (*env)->GetPrimitiveArrayCritical(env, event, NULL) );  }
  ptr_clEnqueueFillBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueFillBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueFillBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (const void * ) (((char *) _pattern_ptr) + pattern_byte_offset), (size_t) pattern_size, (size_t) offset, (size_t) size, (cl_uint) num_events_in_wait_list, (const cl_event * ) (((char *) _event_wait_list_ptr) + event_wait_list_byte_offset), (cl_event * ) (((char *) _event_ptr) + event_byte_offset));
  if ( JNI_FALSE == pattern_is_nio && NULL != pattern ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pattern, _pattern_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == event_wait_list_is_nio && NULL != event_wait_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event_wait_list, _event_wait_list_ptr, 0);  }
  if ( JNI_FALSE == event_is_nio && NULL != event ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event, _event_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueCopyBuffer(long command_queue, long src_buffer, long dst_buffer, long src_offset, long dst_offset, long size, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueCopyBuffer0__JJJJJJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_buffer, jlong src_offset, jlong dst_offset, jlong size, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBuffer;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_buffer, (size_t) src_offset, (size_t) dst_offset, (size_t) size, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueCopyBufferRect(long command_queue, long src_buffer, long dst_buffer, com.jogamp.common.nio.PointerBuffer src_origin, com.jogamp.common.nio.PointerBuffer dst_origin, com.jogamp.common.nio.PointerBuffer region, long src_row_pitch, long src_slice_pitch, long dst_row_pitch, long dst_slice_pitch, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *  src_origin, const size_t *  dst_origin, const size_t *  region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueCopyBufferRect0__JJJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_buffer, jobject src_origin, jint src_origin_byte_offset, jobject dst_origin, jint dst_origin_byte_offset, jobject region, jint region_byte_offset, jlong src_row_pitch, jlong src_slice_pitch, jlong dst_row_pitch, jlong dst_slice_pitch, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *  src_origin, const size_t *  dst_origin, const size_t *  region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBufferRect;
  size_t * _src_origin_ptr = NULL;
  size_t * _dst_origin_ptr = NULL;
  size_t * _region_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != src_origin ) {
        _src_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, src_origin)) + src_origin_byte_offset);
    }

    if ( NULL != dst_origin ) {
        _dst_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, dst_origin)) + dst_origin_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_buffer, (const size_t * ) _src_origin_ptr, (const size_t * ) _dst_origin_ptr, (const size_t * ) _region_ptr, (size_t) src_row_pitch, (size_t) src_slice_pitch, (size_t) dst_row_pitch, (size_t) dst_slice_pitch, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueReadImage(long command_queue, long image, int blocking_read, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long row_pitch, long slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t * , const size_t * , size_t row_pitch, size_t slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueReadImage0__JJILjava_lang_Object_2ILjava_lang_Object_2IJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong image, jint blocking_read, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong row_pitch, jlong slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t * , const size_t * , size_t row_pitch, size_t slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image, (cl_bool) blocking_read, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) row_pitch, (size_t) slice_pitch, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueWriteImage(long command_queue, long image, int blocking_write, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long input_row_pitch, long input_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t * , const size_t * , size_t input_row_pitch, size_t input_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueWriteImage0__JJILjava_lang_Object_2ILjava_lang_Object_2IJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong image, jint blocking_write, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong input_row_pitch, jlong input_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t * , const size_t * , size_t input_row_pitch, size_t input_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image, (cl_bool) blocking_write, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) input_row_pitch, (size_t) input_slice_pitch, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueFillImage(long command_queue, long image, java.nio.Buffer fill_color, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueFillImage(cl_command_queue command_queue, cl_mem image, const void *  fill_color, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueFillImage1__JJLjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong image, jobject fill_color, jint fill_color_byte_offset, jboolean fill_color_is_nio, jobject arg3, jint arg3_byte_offset, jboolean arg3_is_nio, jobject arg4, jint arg4_byte_offset, jboolean arg4_is_nio, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jboolean event_wait_list_is_nio, jobject event, jint event_byte_offset, jboolean event_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem image, const void *  fill_color, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueFillImage;
  void * _fill_color_ptr = NULL;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
  if ( NULL != fill_color ) {
    _fill_color_ptr = (void *) ( JNI_TRUE == fill_color_is_nio ?  (*env)->GetDirectBufferAddress(env, fill_color) :  (*env)->GetPrimitiveArrayCritical(env, fill_color, NULL) );  }
  if ( NULL != arg3 ) {
    _arg3_ptr = (size_t *) ( JNI_TRUE == arg3_is_nio ?  (*env)->GetDirectBufferAddress(env, arg3) :  (*env)->GetPrimitiveArrayCritical(env, arg3, NULL) );  }
  if ( NULL != arg4 ) {
    _arg4_ptr = (size_t *) ( JNI_TRUE == arg4_is_nio ?  (*env)->GetDirectBufferAddress(env, arg4) :  (*env)->GetPrimitiveArrayCritical(env, arg4, NULL) );  }
  if ( NULL != event_wait_list ) {
    _event_wait_list_ptr = (cl_event *) ( JNI_TRUE == event_wait_list_is_nio ?  (*env)->GetDirectBufferAddress(env, event_wait_list) :  (*env)->GetPrimitiveArrayCritical(env, event_wait_list, NULL) );  }
  if ( NULL != event ) {
    _event_ptr = (cl_event *) ( JNI_TRUE == event_is_nio ?  (*env)->GetDirectBufferAddress(env, event) :  (*env)->GetPrimitiveArrayCritical(env, event, NULL) );  }
  ptr_clEnqueueFillImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueFillImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueFillImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image, (const void * ) (((char *) _fill_color_ptr) + fill_color_byte_offset), (const size_t * ) (((char *) _arg3_ptr) + arg3_byte_offset), (const size_t * ) (((char *) _arg4_ptr) + arg4_byte_offset), (cl_uint) num_events_in_wait_list, (const cl_event * ) (((char *) _event_wait_list_ptr) + event_wait_list_byte_offset), (cl_event * ) (((char *) _event_ptr) + event_byte_offset));
  if ( JNI_FALSE == fill_color_is_nio && NULL != fill_color ) {
    (*env)->ReleasePrimitiveArrayCritical(env, fill_color, _fill_color_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == arg3_is_nio && NULL != arg3 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg3, _arg3_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == arg4_is_nio && NULL != arg4 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg4, _arg4_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == event_wait_list_is_nio && NULL != event_wait_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event_wait_list, _event_wait_list_ptr, 0);  }
  if ( JNI_FALSE == event_is_nio && NULL != event ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event, _event_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueCopyImage(long command_queue, long src_image, long dst_image, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, com.jogamp.common.nio.PointerBuffer arg5, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t * , const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueCopyImage0__JJJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_image, jlong dst_image, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jobject arg5, jint arg5_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t * , const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  size_t * _arg5_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != arg5 ) {
        _arg5_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg5)) + arg5_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_image, (cl_mem) (intptr_t) dst_image, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (const size_t * ) _arg5_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueCopyImageToBuffer(long command_queue, long src_image, long dst_buffer, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long dst_offset, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyImageToBuffer(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t * , const size_t * , size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueCopyImageToBuffer0__JJJLjava_lang_Object_2ILjava_lang_Object_2IJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_image, jlong dst_buffer, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong dst_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t * , const size_t * , size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyImageToBuffer;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyImageToBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyImageToBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyImageToBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_image, (cl_mem) (intptr_t) dst_buffer, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) dst_offset, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueCopyBufferToImage(long command_queue, long src_buffer, long dst_image, long src_offset, com.jogamp.common.nio.PointerBuffer arg4, com.jogamp.common.nio.PointerBuffer arg5, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBufferToImage(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueCopyBufferToImage0__JJJJLjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_image, jlong src_offset, jobject arg4, jint arg4_byte_offset, jobject arg5, jint arg5_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBufferToImage;
  size_t * _arg4_ptr = NULL;
  size_t * _arg5_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != arg5 ) {
        _arg5_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg5)) + arg5_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBufferToImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBufferToImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBufferToImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_image, (size_t) src_offset, (const size_t * ) _arg4_ptr, (const size_t * ) _arg5_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: java.nio.ByteBuffer clEnqueueMapBuffer(long command_queue, long buffer, int blocking_map, long map_flags, long offset, long size, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event, java.nio.IntBuffer errcode_ret)
 *     C function: void *  clEnqueueMapBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event, cl_int *  errcode_ret)
 */
JNIEXPORT jobject JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueMapBuffer0__JJIJJJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_map, jlong map_flags, jlong offset, jlong size, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef void *  (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event, cl_int *  errcode_ret);
  _local_ARG ptr_clEnqueueMapBuffer;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  void * _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clEnqueueMapBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMapBuffer != NULL);
  _res = (void *) (* ptr_clEnqueueMapBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_map, (cl_map_flags) map_flags, (size_t) offset, (size_t) size, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr, (cl_int * ) _errcode_ret_ptr);
  jobject _res_jni;
  if(NULL == _res) {
    _res_jni = NULL;
  } else {
    _res_jni = (*env)->NewDirectByteBuffer(env, (void *)_res, size);
  }
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueUnmapMemObject(long command_queue, long memobj, java.nio.Buffer mapped_ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_mem memobj, void *  mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueUnmapMemObject0__JJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong memobj, jobject mapped_ptr, jint mapped_ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem memobj, void *  mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueUnmapMemObject;
  void * _mapped_ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mapped_ptr ) {
        _mapped_ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, mapped_ptr)) + mapped_ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueUnmapMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueUnmapMemObject != NULL);
  _res = (cl_int) (* ptr_clEnqueueUnmapMemObject) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) memobj, (void * ) _mapped_ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueMigrateMemObjects(long command_queue, int num_mem_objects, com.jogamp.common.nio.PointerBuffer mem_objects, long flags, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueMigrateMemObjects(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *  mem_objects, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueMigrateMemObjects1__JILjava_lang_Object_2IZJILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_mem_objects, jobject mem_objects, jint mem_objects_byte_offset, jboolean mem_objects_is_nio, jlong flags, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jboolean event_wait_list_is_nio, jobject event, jint event_byte_offset, jboolean event_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *  mem_objects, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueMigrateMemObjects;
  cl_mem * _mem_objects_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
  if ( NULL != mem_objects ) {
    _mem_objects_ptr = (cl_mem *) ( JNI_TRUE == mem_objects_is_nio ?  (*env)->GetDirectBufferAddress(env, mem_objects) :  (*env)->GetPrimitiveArrayCritical(env, mem_objects, NULL) );  }
  if ( NULL != event_wait_list ) {
    _event_wait_list_ptr = (cl_event *) ( JNI_TRUE == event_wait_list_is_nio ?  (*env)->GetDirectBufferAddress(env, event_wait_list) :  (*env)->GetPrimitiveArrayCritical(env, event_wait_list, NULL) );  }
  if ( NULL != event ) {
    _event_ptr = (cl_event *) ( JNI_TRUE == event_is_nio ?  (*env)->GetDirectBufferAddress(env, event) :  (*env)->GetPrimitiveArrayCritical(env, event, NULL) );  }
  ptr_clEnqueueMigrateMemObjects = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMigrateMemObjects != NULL);
  _res = (cl_int) (* ptr_clEnqueueMigrateMemObjects) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_mem_objects, (const cl_mem * ) (((char *) _mem_objects_ptr) + mem_objects_byte_offset), (cl_mem_migration_flags) flags, (cl_uint) num_events_in_wait_list, (const cl_event * ) (((char *) _event_wait_list_ptr) + event_wait_list_byte_offset), (cl_event * ) (((char *) _event_ptr) + event_byte_offset));
  if ( JNI_FALSE == mem_objects_is_nio && NULL != mem_objects ) {
    (*env)->ReleasePrimitiveArrayCritical(env, mem_objects, _mem_objects_ptr, 0);  }
  if ( JNI_FALSE == event_wait_list_is_nio && NULL != event_wait_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event_wait_list, _event_wait_list_ptr, 0);  }
  if ( JNI_FALSE == event_is_nio && NULL != event ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event, _event_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueNDRangeKernel(long command_queue, long kernel, int work_dim, com.jogamp.common.nio.PointerBuffer global_work_offset, com.jogamp.common.nio.PointerBuffer global_work_size, com.jogamp.common.nio.PointerBuffer local_work_size, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *  global_work_offset, const size_t *  global_work_size, const size_t *  local_work_size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueNDRangeKernel0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong kernel, jint work_dim, jobject global_work_offset, jint global_work_offset_byte_offset, jobject global_work_size, jint global_work_size_byte_offset, jobject local_work_size, jint local_work_size_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *  global_work_offset, const size_t *  global_work_size, const size_t *  local_work_size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueNDRangeKernel;
  size_t * _global_work_offset_ptr = NULL;
  size_t * _global_work_size_ptr = NULL;
  size_t * _local_work_size_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != global_work_offset ) {
        _global_work_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, global_work_offset)) + global_work_offset_byte_offset);
    }

    if ( NULL != global_work_size ) {
        _global_work_size_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, global_work_size)) + global_work_size_byte_offset);
    }

    if ( NULL != local_work_size ) {
        _local_work_size_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, local_work_size)) + local_work_size_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueNDRangeKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueNDRangeKernel != NULL);
  _res = (cl_int) (* ptr_clEnqueueNDRangeKernel) ((cl_command_queue) (intptr_t) command_queue, (cl_kernel) (intptr_t) kernel, (cl_uint) work_dim, (const size_t * ) _global_work_offset_ptr, (const size_t * ) _global_work_size_ptr, (const size_t * ) _local_work_size_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueTask(long command_queue, long kernel, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueTask0__JJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong kernel, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueTask;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueTask = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueTask != NULL);
  _res = (cl_int) (* ptr_clEnqueueTask) ((cl_command_queue) (intptr_t) command_queue, (cl_kernel) (intptr_t) kernel, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueMarkerWithWaitList(long command_queue, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueMarkerWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueMarkerWithWaitList1__JILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jboolean event_wait_list_is_nio, jobject event, jint event_byte_offset, jboolean event_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueMarkerWithWaitList;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
  if ( NULL != event_wait_list ) {
    _event_wait_list_ptr = (cl_event *) ( JNI_TRUE == event_wait_list_is_nio ?  (*env)->GetDirectBufferAddress(env, event_wait_list) :  (*env)->GetPrimitiveArrayCritical(env, event_wait_list, NULL) );  }
  if ( NULL != event ) {
    _event_ptr = (cl_event *) ( JNI_TRUE == event_is_nio ?  (*env)->GetDirectBufferAddress(env, event) :  (*env)->GetPrimitiveArrayCritical(env, event, NULL) );  }
  ptr_clEnqueueMarkerWithWaitList = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMarkerWithWaitList != NULL);
  _res = (cl_int) (* ptr_clEnqueueMarkerWithWaitList) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_events_in_wait_list, (const cl_event * ) (((char *) _event_wait_list_ptr) + event_wait_list_byte_offset), (cl_event * ) (((char *) _event_ptr) + event_byte_offset));
  if ( JNI_FALSE == event_wait_list_is_nio && NULL != event_wait_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event_wait_list, _event_wait_list_ptr, 0);  }
  if ( JNI_FALSE == event_is_nio && NULL != event ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event, _event_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueBarrierWithWaitList(long command_queue, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueBarrierWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueBarrierWithWaitList1__JILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jboolean event_wait_list_is_nio, jobject event, jint event_byte_offset, jboolean event_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueBarrierWithWaitList;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
  if ( NULL != event_wait_list ) {
    _event_wait_list_ptr = (cl_event *) ( JNI_TRUE == event_wait_list_is_nio ?  (*env)->GetDirectBufferAddress(env, event_wait_list) :  (*env)->GetPrimitiveArrayCritical(env, event_wait_list, NULL) );  }
  if ( NULL != event ) {
    _event_ptr = (cl_event *) ( JNI_TRUE == event_is_nio ?  (*env)->GetDirectBufferAddress(env, event) :  (*env)->GetPrimitiveArrayCritical(env, event, NULL) );  }
  ptr_clEnqueueBarrierWithWaitList = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueBarrierWithWaitList != NULL);
  _res = (cl_int) (* ptr_clEnqueueBarrierWithWaitList) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_events_in_wait_list, (const cl_event * ) (((char *) _event_wait_list_ptr) + event_wait_list_byte_offset), (cl_event * ) (((char *) _event_ptr) + event_byte_offset));
  if ( JNI_FALSE == event_wait_list_is_nio && NULL != event_wait_list ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event_wait_list, _event_wait_list_ptr, 0);  }
  if ( JNI_FALSE == event_is_nio && NULL != event ) {
    (*env)->ReleasePrimitiveArrayCritical(env, event, _event_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: java.nio.ByteBuffer clGetExtensionFunctionAddressForPlatform(long platform, java.nio.ByteBuffer func_name)
 *     C function: void *  clGetExtensionFunctionAddressForPlatform(cl_platform_id platform, const char *  func_name)
 */
JNIEXPORT jobject JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetExtensionFunctionAddressForPlatform1__JLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong platform, jobject func_name, jint func_name_byte_offset, jboolean func_name_is_nio, jlong procAddress) {
  typedef void *  (CL_API_CALL*_local_ARG)(cl_platform_id platform, const char *  func_name);
  _local_ARG ptr_clGetExtensionFunctionAddressForPlatform;
  char * _func_name_ptr = NULL;
  void * _res;
  if ( NULL != func_name ) {
    _func_name_ptr = (char *) ( JNI_TRUE == func_name_is_nio ?  (*env)->GetDirectBufferAddress(env, func_name) :  (*env)->GetPrimitiveArrayCritical(env, func_name, NULL) );  }
  ptr_clGetExtensionFunctionAddressForPlatform = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetExtensionFunctionAddressForPlatform != NULL);
  _res = (void *) (* ptr_clGetExtensionFunctionAddressForPlatform) ((cl_platform_id) (intptr_t) platform, (const char * ) (((char *) _func_name_ptr) + func_name_byte_offset));
  if ( JNI_FALSE == func_name_is_nio && NULL != func_name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, func_name, _func_name_ptr, JNI_ABORT);  }
  jobject _res_jni;
  if(NULL == _res) {
    _res_jni = NULL;
  } else {
    _res_jni = (*env)->NewDirectByteBuffer(env, (void *)_res, sizeof(void *) );
    /** 
     * mode: 21, arg #-1
     * cType: CType[(PointerType) 'void *' -> (void) * , size[fixed false, lnx64 8], const[false], is[pointer*1]]
     * cTargetType: CType[(VoidType) 'void', size ZERO, const[false], is[void]]
     * javaType: JType[java.nio.ByteBufferclazz = java.nio.ByteBuffer, is[nioBuffer], descriptor 'Ljava/nio/ByteBuffer;']
     */
  }
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateImage2D(long context, long flags, CLImageFormatImpl image_format, long image_width, long image_height, long image_row_pitch, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateImage2D(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateImage2D1__JJLjava_nio_ByteBuffer_2JJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jobject image_format, jlong image_width, jlong image_height, jlong image_row_pitch, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateImage2D;
  cl_image_format * _image_format_ptr = NULL;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
    if ( NULL != image_format ) {
        _image_format_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_format)) + 0);
    }

  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateImage2D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateImage2D != NULL);
  _res = (cl_mem) (* ptr_clCreateImage2D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (const cl_image_format * ) _image_format_ptr, (size_t) image_width, (size_t) image_height, (size_t) image_row_pitch, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateImage3D(long context, long flags, CLImageFormatImpl image_format, long image_width, long image_height, long image_depth, long image_row_pitch, long image_slice_pitch, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateImage3D(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateImage3D1__JJLjava_nio_ByteBuffer_2JJJJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jobject image_format, jlong image_width, jlong image_height, jlong image_depth, jlong image_row_pitch, jlong image_slice_pitch, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateImage3D;
  cl_image_format * _image_format_ptr = NULL;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
    if ( NULL != image_format ) {
        _image_format_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_format)) + 0);
    }

  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateImage3D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateImage3D != NULL);
  _res = (cl_mem) (* ptr_clCreateImage3D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (const cl_image_format * ) _image_format_ptr, (size_t) image_width, (size_t) image_height, (size_t) image_depth, (size_t) image_row_pitch, (size_t) image_slice_pitch, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueMarker(long command_queue, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueMarker0__JLjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_event *  event);
  _local_ARG ptr_clEnqueueMarker;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueMarker = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMarker != NULL);
  _res = (cl_int) (* ptr_clEnqueueMarker) ((cl_command_queue) (intptr_t) command_queue, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueWaitForEvents(long command_queue, int num_events, com.jogamp.common.nio.PointerBuffer event_list)
 *     C function: cl_int clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, const cl_event *  event_list)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueWaitForEvents0__JILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_events, jobject event_list, jint event_list_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_events, const cl_event *  event_list);
  _local_ARG ptr_clEnqueueWaitForEvents;
  cl_event * _event_list_ptr = NULL;
  cl_int _res;
    if ( NULL != event_list ) {
        _event_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_list)) + event_list_byte_offset);
    }

  ptr_clEnqueueWaitForEvents = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWaitForEvents != NULL);
  _res = (cl_int) (* ptr_clEnqueueWaitForEvents) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_events, (const cl_event * ) _event_list_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueBarrier(long command_queue)
 *     C function: cl_int clEnqueueBarrier(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueBarrier0__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clEnqueueBarrier;
  cl_int _res;
  ptr_clEnqueueBarrier = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueBarrier != NULL);
  _res = (cl_int) (* ptr_clEnqueueBarrier) ((cl_command_queue) (intptr_t) command_queue);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clUnloadCompiler()
 *     C function: cl_int clUnloadCompiler()
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clUnloadCompiler1__J(JNIEnv *env, jobject _unused, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)();
  _local_ARG ptr_clUnloadCompiler;
  cl_int _res;
  ptr_clUnloadCompiler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clUnloadCompiler != NULL);
  _res = (cl_int) (* ptr_clUnloadCompiler) ();
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clIcdGetPlatformIDsKHR(int arg0, com.jogamp.common.nio.PointerBuffer arg1, java.nio.IntBuffer arg2)
 *     C function: cl_int clIcdGetPlatformIDsKHR(cl_uint, cl_platform_id * , cl_uint * )
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clIcdGetPlatformIDsKHR0__ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint arg0, jobject arg1, jint arg1_byte_offset, jobject arg2, jint arg2_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint, cl_platform_id * , cl_uint * );
  _local_ARG ptr_clIcdGetPlatformIDsKHR;
  cl_platform_id * _arg1_ptr = NULL;
  cl_uint * _arg2_ptr = NULL;
  cl_int _res;
    if ( NULL != arg1 ) {
        _arg1_ptr = (cl_platform_id *) (((char*) (*env)->GetDirectBufferAddress(env, arg1)) + arg1_byte_offset);
    }

    if ( NULL != arg2 ) {
        _arg2_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, arg2)) + arg2_byte_offset);
    }

  ptr_clIcdGetPlatformIDsKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clIcdGetPlatformIDsKHR != NULL);
  _res = (cl_int) (* ptr_clIcdGetPlatformIDsKHR) ((cl_uint) arg0, (cl_platform_id * ) _arg1_ptr, (cl_uint * ) _arg2_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clTerminateContextKHR(long arg0)
 *     C function: cl_int clTerminateContextKHR(cl_context)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clTerminateContextKHR1__JJ(JNIEnv *env, jobject _unused, jlong arg0, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context);
  _local_ARG ptr_clTerminateContextKHR;
  cl_int _res;
  ptr_clTerminateContextKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clTerminateContextKHR != NULL);
  _res = (cl_int) (* ptr_clTerminateContextKHR) ((cl_context) (intptr_t) arg0);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clReleaseDeviceEXT(long arg0)
 *     C function: cl_int clReleaseDeviceEXT(cl_device_id)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clReleaseDeviceEXT1__JJ(JNIEnv *env, jobject _unused, jlong arg0, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id);
  _local_ARG ptr_clReleaseDeviceEXT;
  cl_int _res;
  ptr_clReleaseDeviceEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseDeviceEXT != NULL);
  _res = (cl_int) (* ptr_clReleaseDeviceEXT) ((cl_device_id) (intptr_t) arg0);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clRetainDeviceEXT(long arg0)
 *     C function: cl_int clRetainDeviceEXT(cl_device_id)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clRetainDeviceEXT1__JJ(JNIEnv *env, jobject _unused, jlong arg0, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id);
  _local_ARG ptr_clRetainDeviceEXT;
  cl_int _res;
  ptr_clRetainDeviceEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainDeviceEXT != NULL);
  _res = (cl_int) (* ptr_clRetainDeviceEXT) ((cl_device_id) (intptr_t) arg0);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clCreateSubDevicesEXT(long arg0, java.nio.LongBuffer arg1, int arg2, com.jogamp.common.nio.PointerBuffer arg3, java.nio.IntBuffer arg4)
 *     C function: cl_int clCreateSubDevicesEXT(cl_device_id, const cl_device_partition_property_ext * , cl_uint, cl_device_id * , cl_uint * )
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateSubDevicesEXT1__JLjava_lang_Object_2IZILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong arg0, jobject arg1, jint arg1_byte_offset, jboolean arg1_is_nio, jint arg2, jobject arg3, jint arg3_byte_offset, jboolean arg3_is_nio, jobject arg4, jint arg4_byte_offset, jboolean arg4_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id, const cl_device_partition_property_ext * , cl_uint, cl_device_id * , cl_uint * );
  _local_ARG ptr_clCreateSubDevicesEXT;
  cl_device_partition_property_ext * _arg1_ptr = NULL;
  cl_device_id * _arg3_ptr = NULL;
  cl_uint * _arg4_ptr = NULL;
  cl_int _res;
  if ( NULL != arg1 ) {
    _arg1_ptr = (cl_device_partition_property_ext *) ( JNI_TRUE == arg1_is_nio ?  (*env)->GetDirectBufferAddress(env, arg1) :  (*env)->GetPrimitiveArrayCritical(env, arg1, NULL) );  }
  if ( NULL != arg3 ) {
    _arg3_ptr = (cl_device_id *) ( JNI_TRUE == arg3_is_nio ?  (*env)->GetDirectBufferAddress(env, arg3) :  (*env)->GetPrimitiveArrayCritical(env, arg3, NULL) );  }
  if ( NULL != arg4 ) {
    _arg4_ptr = (cl_uint *) ( JNI_TRUE == arg4_is_nio ?  (*env)->GetDirectBufferAddress(env, arg4) :  (*env)->GetPrimitiveArrayCritical(env, arg4, NULL) );  }
  ptr_clCreateSubDevicesEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSubDevicesEXT != NULL);
  _res = (cl_int) (* ptr_clCreateSubDevicesEXT) ((cl_device_id) (intptr_t) arg0, (const cl_device_partition_property_ext * ) (((char *) _arg1_ptr) + arg1_byte_offset), (cl_uint) arg2, (cl_device_id * ) (((char *) _arg3_ptr) + arg3_byte_offset), (cl_uint * ) (((char *) _arg4_ptr) + arg4_byte_offset));
  if ( JNI_FALSE == arg1_is_nio && NULL != arg1 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg1, _arg1_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == arg3_is_nio && NULL != arg3 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg3, _arg3_ptr, 0);  }
  if ( JNI_FALSE == arg4_is_nio && NULL != arg4 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg4, _arg4_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateFromGLBuffer(long context, long flags, int bufobj, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLBuffer(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateFromGLBuffer1__JJILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint bufobj, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLBuffer;
  int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLBuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLuint) bufobj, (int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateFromGLTexture(long context, long flags, int target, int miplevel, int texture, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLTexture(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateFromGLTexture1__JJIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint target, jint miplevel, jint texture, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLTexture;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLTexture = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLTexture != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLTexture) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLenum) target, (cl_GLint) miplevel, (cl_GLuint) texture, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateFromGLRenderbuffer(long context, long flags, int renderbuffer, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLRenderbuffer(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateFromGLRenderbuffer1__JJILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint renderbuffer, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLRenderbuffer;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLRenderbuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLRenderbuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLRenderbuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLuint) renderbuffer, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetGLObjectInfo(long memobj, java.nio.IntBuffer gl_object_type, java.nio.IntBuffer gl_object_name)
 *     C function: cl_int clGetGLObjectInfo(cl_mem memobj, cl_gl_object_type *  gl_object_type, cl_GLuint *  gl_object_name)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetGLObjectInfo1__JLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong memobj, jobject gl_object_type, jint gl_object_type_byte_offset, jboolean gl_object_type_is_nio, jobject gl_object_name, jint gl_object_name_byte_offset, jboolean gl_object_name_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_gl_object_type *  gl_object_type, cl_GLuint *  gl_object_name);
  _local_ARG ptr_clGetGLObjectInfo;
  cl_gl_object_type * _gl_object_type_ptr = NULL;
  cl_GLuint * _gl_object_name_ptr = NULL;
  cl_int _res;
  if ( NULL != gl_object_type ) {
    _gl_object_type_ptr = (cl_gl_object_type *) ( JNI_TRUE == gl_object_type_is_nio ?  (*env)->GetDirectBufferAddress(env, gl_object_type) :  (*env)->GetPrimitiveArrayCritical(env, gl_object_type, NULL) );  }
  if ( NULL != gl_object_name ) {
    _gl_object_name_ptr = (cl_GLuint *) ( JNI_TRUE == gl_object_name_is_nio ?  (*env)->GetDirectBufferAddress(env, gl_object_name) :  (*env)->GetPrimitiveArrayCritical(env, gl_object_name, NULL) );  }
  ptr_clGetGLObjectInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLObjectInfo != NULL);
  _res = (cl_int) (* ptr_clGetGLObjectInfo) ((cl_mem) (intptr_t) memobj, (cl_gl_object_type * ) (((char *) _gl_object_type_ptr) + gl_object_type_byte_offset), (cl_GLuint * ) (((char *) _gl_object_name_ptr) + gl_object_name_byte_offset));
  if ( JNI_FALSE == gl_object_type_is_nio && NULL != gl_object_type ) {
    (*env)->ReleasePrimitiveArrayCritical(env, gl_object_type, _gl_object_type_ptr, 0);  }
  if ( JNI_FALSE == gl_object_name_is_nio && NULL != gl_object_name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, gl_object_name, _gl_object_name_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetGLTextureInfo(long memobj, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetGLTextureInfo(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetGLTextureInfo1__JIJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong memobj, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jboolean param_value_is_nio, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jboolean param_value_size_ret_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetGLTextureInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
  if ( NULL != param_value ) {
    _param_value_ptr = (void *) ( JNI_TRUE == param_value_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value) :  (*env)->GetPrimitiveArrayCritical(env, param_value, NULL) );  }
  if ( NULL != param_value_size_ret ) {
    _param_value_size_ret_ptr = (size_t *) ( JNI_TRUE == param_value_size_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value_size_ret) :  (*env)->GetPrimitiveArrayCritical(env, param_value_size_ret, NULL) );  }
  ptr_clGetGLTextureInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLTextureInfo != NULL);
  _res = (cl_int) (* ptr_clGetGLTextureInfo) ((cl_mem) (intptr_t) memobj, (cl_gl_texture_info) param_name, (size_t) param_value_size, (void * ) (((char *) _param_value_ptr) + param_value_byte_offset), (size_t * ) (((char *) _param_value_size_ret_ptr) + param_value_size_ret_byte_offset));
  if ( JNI_FALSE == param_value_is_nio && NULL != param_value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value, _param_value_ptr, 0);  }
  if ( JNI_FALSE == param_value_size_ret_is_nio && NULL != param_value_size_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value_size_ret, _param_value_size_ret_ptr, 0);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueAcquireGLObjects(long command_queue, int num_objects, com.jogamp.common.nio.PointerBuffer mem_objects, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueAcquireGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueAcquireGLObjects0__JILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_objects, jobject mem_objects, jint mem_objects_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueAcquireGLObjects;
  cl_mem * _mem_objects_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mem_objects ) {
        _mem_objects_ptr = (cl_mem *) (((char*) (*env)->GetDirectBufferAddress(env, mem_objects)) + mem_objects_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueAcquireGLObjects = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueAcquireGLObjects != NULL);
  _res = (cl_int) (* ptr_clEnqueueAcquireGLObjects) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_objects, (const cl_mem * ) _mem_objects_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clEnqueueReleaseGLObjects(long command_queue, int num_objects, com.jogamp.common.nio.PointerBuffer mem_objects, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReleaseGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clEnqueueReleaseGLObjects0__JILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_objects, jobject mem_objects, jint mem_objects_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReleaseGLObjects;
  cl_mem * _mem_objects_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mem_objects ) {
        _mem_objects_ptr = (cl_mem *) (((char*) (*env)->GetDirectBufferAddress(env, mem_objects)) + mem_objects_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReleaseGLObjects = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReleaseGLObjects != NULL);
  _res = (cl_int) (* ptr_clEnqueueReleaseGLObjects) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_objects, (const cl_mem * ) _mem_objects_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateFromGLTexture2D(long context, long flags, int target, int miplevel, int texture, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLTexture2D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateFromGLTexture2D1__JJIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint target, jint miplevel, jint texture, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLTexture2D;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLTexture2D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLTexture2D != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLTexture2D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLenum) target, (cl_GLint) miplevel, (cl_GLuint) texture, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateFromGLTexture3D(long context, long flags, int target, int miplevel, int texture, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLTexture3D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateFromGLTexture3D1__JJIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint target, jint miplevel, jint texture, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLTexture3D;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLTexture3D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLTexture3D != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLTexture3D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLenum) target, (cl_GLint) miplevel, (cl_GLuint) texture, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: int clGetGLContextInfoKHR(com.jogamp.common.nio.PointerBuffer properties, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetGLContextInfoKHR(const cl_context_properties *  properties, cl_gl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clGetGLContextInfoKHR0__Ljava_lang_Object_2IIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jobject properties, jint properties_byte_offset, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(const cl_context_properties *  properties, cl_gl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetGLContextInfoKHR;
  cl_context_properties * _properties_ptr = NULL;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != properties ) {
        _properties_ptr = (cl_context_properties *) (((char*) (*env)->GetDirectBufferAddress(env, properties)) + properties_byte_offset);
    }

    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetGLContextInfoKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLContextInfoKHR != NULL);
  _res = (cl_int) (* ptr_clGetGLContextInfoKHR) ((const cl_context_properties * ) _properties_ptr, (cl_gl_context_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLImpl12
 *    Java method: long clCreateEventFromGLsyncKHR(long arg0, long arg1, java.nio.IntBuffer arg2)
 *     C function: cl_event clCreateEventFromGLsyncKHR(cl_context, cl_GLsync, cl_int * )
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLImpl12_dispatch_1clCreateEventFromGLsyncKHR1__JJLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong arg0, jlong arg1, jobject arg2, jint arg2_byte_offset, jboolean arg2_is_nio, jlong procAddress) {
  typedef cl_event (CL_API_CALL*_local_ARG)(cl_context, cl_GLsync, cl_int * );
  _local_ARG ptr_clCreateEventFromGLsyncKHR;
  cl_int * _arg2_ptr = NULL;
  cl_event _res;
  if ( NULL != arg2 ) {
    _arg2_ptr = (cl_int *) ( JNI_TRUE == arg2_is_nio ?  (*env)->GetDirectBufferAddress(env, arg2) :  (*env)->GetPrimitiveArrayCritical(env, arg2, NULL) );  }
  ptr_clCreateEventFromGLsyncKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateEventFromGLsyncKHR != NULL);
  _res = (cl_event) (* ptr_clCreateEventFromGLsyncKHR) ((cl_context) (intptr_t) arg0, (cl_GLsync) (intptr_t) arg1, (cl_int * ) (((char *) _arg2_ptr) + arg2_byte_offset));
  if ( JNI_FALSE == arg2_is_nio && NULL != arg2 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg2, _arg2_ptr, 0);  }
  jlong _res_jni = (jlong) (intptr_t) _res;
  return _res_jni;
}


