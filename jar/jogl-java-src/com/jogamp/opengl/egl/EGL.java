/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 18 14:58:50 CEST 2023 ----! */
/* !---- Java-Unit: [pkg com.jogamp.opengl.egl, cls EGL], ../build/jogl/gensrc/classes/com/jogamp/opengl/egl/EGL.java ----! */

package com.jogamp.opengl.egl;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;
import com.jogamp.common.util.*;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class EGL {

  /** Defined as part of enum type "khronos_boolean_enum_t" with expression '<code>0</code>', CType: int */
  public static final int KHRONOS_FALSE = 0x0;
  /** Defined as part of enum type "khronos_boolean_enum_t" with expression '<code>1</code>', CType: int */
  public static final int KHRONOS_TRUE = 0x1;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" with expression '<code>0x30B6</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x30b6;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X" with expression '<code>0x30B4</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x30b4;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_MULTISAMPLE_RESOLVE_DEFAULT" with expression '<code>0x309A</code>', CType: int */
  public static final int EGL_MULTISAMPLE_RESOLVE_DEFAULT = 0x309a;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" with expression '<code>0x30B8</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x30b8;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_colorspace</code><br>Alias for: <code>EGL_GL_COLORSPACE_KHR</code><br>
Define "EGL_GL_COLORSPACE" with expression '<code>0x309D</code>', CType: int */
  public static final int EGL_GL_COLORSPACE = 0x309d;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_CURRENT_SURFACE" with expression '<code>0x3007</code>', CType: int */
  public static final int EGL_BAD_CURRENT_SURFACE = 0x3007;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_BIND_TO_TEXTURE_RGB" with expression '<code>0x3039</code>', CType: int */
  public static final int EGL_BIND_TO_TEXTURE_RGB = 0x3039;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_TEXTURE_FORMAT" with expression '<code>0x3080</code>', CType: int */
  public static final int EGL_TEXTURE_FORMAT = 0x3080;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_COLOR_BUFFER_TYPE" with expression '<code>0x303F</code>', CType: int */
  public static final int EGL_COLOR_BUFFER_TYPE = 0x303f;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_ALPHA_FORMAT_NONPRE" with expression '<code>0x308B</code>', CType: int */
  public static final int EGL_ALPHA_FORMAT_NONPRE = 0x308b;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_MULTISAMPLE_RESOLVE_BOX" with expression '<code>0x309B</code>', CType: int */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX = 0x309b;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_SURFACE_TYPE" with expression '<code>0x3033</code>', CType: int */
  public static final int EGL_SURFACE_TYPE = 0x3033;
  /** <code>EGL_VERSION_1_5</code><br>Define "EGL_CONTEXT_OPENGL_DEBUG" with expression '<code>0x31B0</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_DEBUG = 0x31b0;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRANSPARENT_TYPE" with expression '<code>0x3034</code>', CType: int */
  public static final int EGL_TRANSPARENT_TYPE = 0x3034;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_BACK_BUFFER" with expression '<code>0x3084</code>', CType: int */
  public static final int EGL_BACK_BUFFER = 0x3084;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_LUMINANCE_SIZE" with expression '<code>0x303D</code>', CType: int */
  public static final int EGL_LUMINANCE_SIZE = 0x303d;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_MIN_SWAP_INTERVAL" with expression '<code>0x303B</code>', CType: int */
  public static final int EGL_MIN_SWAP_INTERVAL = 0x303b;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_CONTEXT_LOST" with expression '<code>0x300E</code>', CType: int */
  public static final int EGL_CONTEXT_LOST = 0x300e;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_ALPHA_FORMAT" with expression '<code>0x3088</code>', CType: int */
  public static final int EGL_VG_ALPHA_FORMAT = 0x3088;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_cl_event</code><br>Alias for: <code>EGL_SYNC_CL_EVENT_COMPLETE_KHR</code><br>
Define "EGL_SYNC_CL_EVENT_COMPLETE" with expression '<code>0x30FF</code>', CType: int */
  public static final int EGL_SYNC_CL_EVENT_COMPLETE = 0x30ff;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_ALPHA_FORMAT_NONPRE" with expression '<code>0x308B</code>', CType: int */
  public static final int EGL_VG_ALPHA_FORMAT_NONPRE = 0x308b;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_SAMPLE_BUFFERS" with expression '<code>0x3032</code>', CType: int */
  public static final int EGL_SAMPLE_BUFFERS = 0x3032;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRANSPARENT_BLUE_VALUE" with expression '<code>0x3035</code>', CType: int */
  public static final int EGL_TRANSPARENT_BLUE_VALUE = 0x3035;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_ALPHA_MASK_SIZE" with expression '<code>0x303E</code>', CType: int */
  public static final int EGL_ALPHA_MASK_SIZE = 0x303e;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code>, <code>EGL_EXT_create_context_robustness</code><br>Alias for: <code>EGL_NO_RESET_NOTIFICATION_KHR</code>, <code>EGL_NO_RESET_NOTIFICATION_EXT</code><br>
Define "EGL_NO_RESET_NOTIFICATION" with expression '<code>0x31BE</code>', CType: int */
  public static final int EGL_NO_RESET_NOTIFICATION = 0x31be;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_renderbuffer_image</code><br>Alias for: <code>EGL_GL_RENDERBUFFER_KHR</code><br>
Define "EGL_GL_RENDERBUFFER" with expression '<code>0x30B9</code>', CType: int */
  public static final int EGL_GL_RENDERBUFFER = 0x30b9;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_cl_event</code><br>Alias for: <code>EGL_SYNC_CL_EVENT_KHR</code><br>
Define "EGL_SYNC_CL_EVENT" with expression '<code>0x30FE</code>', CType: int */
  public static final int EGL_SYNC_CL_EVENT = 0x30fe;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRANSPARENT_RGB" with expression '<code>0x3052</code>', CType: int */
  public static final int EGL_TRANSPARENT_RGB = 0x3052;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_WINDOW_BIT" with expression '<code>0x0004</code>', CType: int */
  public static final int EGL_WINDOW_BIT = 0x4;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_ALPHA_FORMAT" with expression '<code>0x3088</code>', CType: int */
  public static final int EGL_ALPHA_FORMAT = 0x3088;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_OPENGL_ES2_BIT" with expression '<code>0x0004</code>', CType: int */
  public static final int EGL_OPENGL_ES2_BIT = 0x4;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_DISPLAY" with expression '<code>0x3008</code>', CType: int */
  public static final int EGL_BAD_DISPLAY = 0x3008;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_PARAMETER" with expression '<code>0x300C</code>', CType: int */
  public static final int EGL_BAD_PARAMETER = 0x300c;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_CONTEXT" with expression '<code>0x3006</code>', CType: int */
  public static final int EGL_BAD_CONTEXT = 0x3006;
  /** <code>EGL_VERSION_1_5</code><br>Define "EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE" with expression '<code>0x31B1</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE = 0x31b1;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_MULTISAMPLE_RESOLVE" with expression '<code>0x3099</code>', CType: int */
  public static final int EGL_MULTISAMPLE_RESOLVE = 0x3099;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_SLOW_CONFIG" with expression '<code>0x3050</code>', CType: int */
  public static final int EGL_SLOW_CONFIG = 0x3050;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_FALSE" with expression '<code>0</code>', CType: int */
  public static final int EGL_FALSE = 0x0;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_SINGLE_BUFFER" with expression '<code>0x3085</code>', CType: int */
  public static final int EGL_SINGLE_BUFFER = 0x3085;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_MULTISAMPLE_RESOLVE_BOX_BIT" with expression '<code>0x0200</code>', CType: int */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX_BIT = 0x200;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_COLORSPACE_LINEAR" with expression '<code>0x308A</code>', CType: int */
  public static final int EGL_COLORSPACE_LINEAR = 0x308a;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_EXTENSIONS" with expression '<code>0x3055</code>', CType: int */
  public static final int EGL_EXTENSIONS = 0x3055;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_ALPHA_FORMAT_PRE" with expression '<code>0x308C</code>', CType: int */
  public static final int EGL_ALPHA_FORMAT_PRE = 0x308c;
  /** <code>EGL_VERSION_1_3</code>, <code>EGL_KHR_config_attribs</code><br>Alias for: <code>EGL_CONFORMANT_KHR</code><br>
Define "EGL_CONFORMANT" with expression '<code>0x3042</code>', CType: int */
  public static final int EGL_CONFORMANT = 0x3042;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_reusable_sync</code><br>Alias for: <code>EGL_SIGNALED_NV</code>, <code>EGL_SIGNALED_KHR</code><br>
Define "EGL_SIGNALED" with expression '<code>0x30F2</code>', CType: int */
  public static final int EGL_SIGNALED = 0x30f2;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_SAMPLES" with expression '<code>0x3031</code>', CType: int */
  public static final int EGL_SAMPLES = 0x3031;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_LUMINANCE_BUFFER" with expression '<code>0x308F</code>', CType: int */
  public static final int EGL_LUMINANCE_BUFFER = 0x308f;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code>, <code>EGL_EXT_create_context_robustness</code><br>Alias for: <code>EGL_LOSE_CONTEXT_ON_RESET_KHR</code>, <code>EGL_LOSE_CONTEXT_ON_RESET_EXT</code><br>
Define "EGL_LOSE_CONTEXT_ON_RESET" with expression '<code>0x31BF</code>', CType: int */
  public static final int EGL_LOSE_CONTEXT_ON_RESET = 0x31bf;
  /** <code>EGL_VERSION_1_3</code>, <code>EGL_KHR_config_attribs</code><br>Alias for: <code>EGL_VG_COLORSPACE_LINEAR_BIT_KHR</code><br>
Define "EGL_VG_COLORSPACE_LINEAR_BIT" with expression '<code>0x0020</code>', CType: int */
  public static final int EGL_VG_COLORSPACE_LINEAR_BIT = 0x20;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X" with expression '<code>0x30B3</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x30b3;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y" with expression '<code>0x30B5</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x30b5;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_DEPTH_SIZE" with expression '<code>0x3025</code>', CType: int */
  public static final int EGL_DEPTH_SIZE = 0x3025;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_MAX_PBUFFER_HEIGHT" with expression '<code>0x302A</code>', CType: int */
  public static final int EGL_MAX_PBUFFER_HEIGHT = 0x302a;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_CONFIG" with expression '<code>0x3005</code>', CType: int */
  public static final int EGL_BAD_CONFIG = 0x3005;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_cubemap_image</code><br>Alias for: <code>EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR</code><br>
Define "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z" with expression '<code>0x30B7</code>', CType: int */
  public static final int EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x30b7;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_3D_image</code><br>Alias for: <code>EGL_GL_TEXTURE_ZOFFSET_KHR</code><br>
Define "EGL_GL_TEXTURE_ZOFFSET" with expression '<code>0x30BD</code>', CType: int */
  public static final int EGL_GL_TEXTURE_ZOFFSET = 0x30bd;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_CONTEXT_CLIENT_VERSION" with expression '<code>0x3098</code>', CType: int */
  public static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_SWAP_BEHAVIOR_PRESERVED_BIT" with expression '<code>0x0400</code>', CType: int */
  public static final int EGL_SWAP_BEHAVIOR_PRESERVED_BIT = 0x400;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_SWAP_BEHAVIOR" with expression '<code>0x3093</code>', CType: int */
  public static final int EGL_SWAP_BEHAVIOR = 0x3093;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_reusable_sync</code><br>Alias for: <code>EGL_CONDITION_SATISFIED_NV</code>, <code>EGL_CONDITION_SATISFIED_KHR</code><br>
Define "EGL_CONDITION_SATISFIED" with expression '<code>0x30F6</code>', CType: int */
  public static final int EGL_CONDITION_SATISFIED = 0x30f6;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_MIPMAP_TEXTURE" with expression '<code>0x3082</code>', CType: int */
  public static final int EGL_MIPMAP_TEXTURE = 0x3082;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_WIDTH" with expression '<code>0x3057</code>', CType: int */
  public static final int EGL_WIDTH = 0x3057;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_cl_event</code><br>Alias for: <code>EGL_CL_EVENT_HANDLE_KHR</code><br>
Define "EGL_CL_EVENT_HANDLE" with expression '<code>0x309C</code>', CType: int */
  public static final int EGL_CL_EVENT_HANDLE = 0x309c;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_READ" with expression '<code>0x305A</code>', CType: int */
  public static final int EGL_READ = 0x305a;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_reusable_sync</code><br>Alias for: <code>EGL_SYNC_TYPE_NV</code>, <code>EGL_SYNC_TYPE_KHR</code><br>
Define "EGL_SYNC_TYPE" with expression '<code>0x30F7</code>', CType: int */
  public static final int EGL_SYNC_TYPE = 0x30f7;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_RENDER_BUFFER" with expression '<code>0x3086</code>', CType: int */
  public static final int EGL_RENDER_BUFFER = 0x3086;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRUE" with expression '<code>1</code>', CType: int */
  public static final int EGL_TRUE = 0x1;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_BUFFER_PRESERVED" with expression '<code>0x3094</code>', CType: int */
  public static final int EGL_BUFFER_PRESERVED = 0x3094;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_OPENGL_ES3_BIT_KHR</code><br>
Define "EGL_OPENGL_ES3_BIT" with expression '<code>0x00000040</code>', CType: int */
  public static final int EGL_OPENGL_ES3_BIT = 0x40;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_MATCH_NATIVE_PIXMAP" with expression '<code>0x3041</code>', CType: int */
  public static final int EGL_MATCH_NATIVE_PIXMAP = 0x3041;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_BUFFER_DESTROYED" with expression '<code>0x3095</code>', CType: int */
  public static final int EGL_BUFFER_DESTROYED = 0x3095;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_colorspace</code><br>Alias for: <code>EGL_GL_COLORSPACE_LINEAR_KHR</code><br>
Define "EGL_GL_COLORSPACE_LINEAR" with expression '<code>0x308A</code>', CType: int */
  public static final int EGL_GL_COLORSPACE_LINEAR = 0x308a;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_COLORSPACE" with expression '<code>0x3087</code>', CType: int */
  public static final int EGL_COLORSPACE = 0x3087;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_PBUFFER_BIT" with expression '<code>0x0001</code>', CType: int */
  public static final int EGL_PBUFFER_BIT = 0x1;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_LEVEL" with expression '<code>0x3029</code>', CType: int */
  public static final int EGL_LEVEL = 0x3029;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_reusable_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>EGL_UNSIGNALED_KHR</code>, <code>EGL_UNSIGNALED_NV</code><br>
Define "EGL_UNSIGNALED" with expression '<code>0x30F3</code>', CType: int */
  public static final int EGL_UNSIGNALED = 0x30f3;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR</code><br>
Define "EGL_CONTEXT_OPENGL_PROFILE_MASK" with expression '<code>0x30FD</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_PROFILE_MASK = 0x30fd;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_STENCIL_SIZE" with expression '<code>0x3026</code>', CType: int */
  public static final int EGL_STENCIL_SIZE = 0x3026;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code>, <code>EGL_EXT_create_context_robustness</code><br>Alias for: <code>EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR</code>, <code>EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT</code><br>
Define "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY" with expression '<code>0x31BD</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY = 0x31bd;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_GREEN_SIZE" with expression '<code>0x3023</code>', CType: int */
  public static final int EGL_GREEN_SIZE = 0x3023;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_TEXTURE_2D" with expression '<code>0x305F</code>', CType: int */
  public static final int EGL_TEXTURE_2D = 0x305f;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_ACCESS" with expression '<code>0x3002</code>', CType: int */
  public static final int EGL_BAD_ACCESS = 0x3002;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_DISPLAY_SCALING" with expression '<code>10000</code>', CType: int */
  public static final int EGL_DISPLAY_SCALING = 0x2710;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_SURFACE" with expression '<code>0x300D</code>', CType: int */
  public static final int EGL_BAD_SURFACE = 0x300d;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_MIPMAP_LEVEL" with expression '<code>0x3083</code>', CType: int */
  public static final int EGL_MIPMAP_LEVEL = 0x3083;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BLUE_SIZE" with expression '<code>0x3022</code>', CType: int */
  public static final int EGL_BLUE_SIZE = 0x3022;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_ATTRIBUTE" with expression '<code>0x3004</code>', CType: int */
  public static final int EGL_BAD_ATTRIBUTE = 0x3004;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_CONTEXT_MAJOR_VERSION_KHR</code><br>
Define "EGL_CONTEXT_MAJOR_VERSION" with expression '<code>0x3098</code>', CType: int */
  public static final int EGL_CONTEXT_MAJOR_VERSION = 0x3098;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_reusable_sync</code><br>Alias for: <code>EGL_SYNC_STATUS_NV</code>, <code>EGL_SYNC_STATUS_KHR</code><br>
Define "EGL_SYNC_STATUS" with expression '<code>0x30F1</code>', CType: int */
  public static final int EGL_SYNC_STATUS = 0x30f1;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_OPENGL_ES_API" with expression '<code>0x30A0</code>', CType: int */
  public static final int EGL_OPENGL_ES_API = 0x30a0;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_CONTEXT_CLIENT_TYPE" with expression '<code>0x3097</code>', CType: int */
  public static final int EGL_CONTEXT_CLIENT_TYPE = 0x3097;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_NATIVE_PIXMAP" with expression '<code>0x300A</code>', CType: int */
  public static final int EGL_BAD_NATIVE_PIXMAP = 0x300a;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_reusable_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>EGL_TIMEOUT_EXPIRED_KHR</code>, <code>EGL_TIMEOUT_EXPIRED_NV</code><br>
Define "EGL_TIMEOUT_EXPIRED" with expression '<code>0x30F5</code>', CType: int */
  public static final int EGL_TIMEOUT_EXPIRED = 0x30f5;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_reusable_sync</code><br>Alias for: <code>EGL_SYNC_FLUSH_COMMANDS_BIT_NV</code>, <code>EGL_SYNC_FLUSH_COMMANDS_BIT_KHR</code><br>
Define "EGL_SYNC_FLUSH_COMMANDS_BIT" with expression '<code>0x0001</code>', CType: int */
  public static final int EGL_SYNC_FLUSH_COMMANDS_BIT = 0x1;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_colorspace</code><br>Alias for: <code>EGL_GL_COLORSPACE_SRGB_KHR</code><br>
Define "EGL_GL_COLORSPACE_SRGB" with expression '<code>0x3089</code>', CType: int */
  public static final int EGL_GL_COLORSPACE_SRGB = 0x3089;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_VERTICAL_RESOLUTION" with expression '<code>0x3091</code>', CType: int */
  public static final int EGL_VERTICAL_RESOLUTION = 0x3091;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_COLORSPACE" with expression '<code>0x3087</code>', CType: int */
  public static final int EGL_VG_COLORSPACE = 0x3087;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_COLORSPACE_LINEAR" with expression '<code>0x308A</code>', CType: int */
  public static final int EGL_VG_COLORSPACE_LINEAR = 0x308a;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_CONFIG_CAVEAT" with expression '<code>0x3027</code>', CType: int */
  public static final int EGL_CONFIG_CAVEAT = 0x3027;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_PIXEL_ASPECT_RATIO" with expression '<code>0x3092</code>', CType: int */
  public static final int EGL_PIXEL_ASPECT_RATIO = 0x3092;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR</code><br>
Define "EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT" with expression '<code>0x00000001</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT = 0x1;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_TEXTURE_TARGET" with expression '<code>0x3081</code>', CType: int */
  public static final int EGL_TEXTURE_TARGET = 0x3081;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_CLIENT_APIS" with expression '<code>0x308D</code>', CType: int */
  public static final int EGL_CLIENT_APIS = 0x308d;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_ALPHA_FORMAT_PRE" with expression '<code>0x308C</code>', CType: int */
  public static final int EGL_VG_ALPHA_FORMAT_PRE = 0x308c;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_BIND_TO_TEXTURE_RGBA" with expression '<code>0x303A</code>', CType: int */
  public static final int EGL_BIND_TO_TEXTURE_RGBA = 0x303a;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NATIVE_VISUAL_TYPE" with expression '<code>0x302F</code>', CType: int */
  public static final int EGL_NATIVE_VISUAL_TYPE = 0x302f;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_MATCH" with expression '<code>0x3009</code>', CType: int */
  public static final int EGL_BAD_MATCH = 0x3009;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NON_CONFORMANT_CONFIG" with expression '<code>0x3051</code>', CType: int */
  public static final int EGL_NON_CONFORMANT_CONFIG = 0x3051;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_TEXTURE_RGB" with expression '<code>0x305D</code>', CType: int */
  public static final int EGL_TEXTURE_RGB = 0x305d;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_RGB_BUFFER" with expression '<code>0x308E</code>', CType: int */
  public static final int EGL_RGB_BUFFER = 0x308e;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_CONTEXT_MINOR_VERSION_KHR</code><br>
Define "EGL_CONTEXT_MINOR_VERSION" with expression '<code>0x30FB</code>', CType: int */
  public static final int EGL_CONTEXT_MINOR_VERSION = 0x30fb;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_HORIZONTAL_RESOLUTION" with expression '<code>0x3090</code>', CType: int */
  public static final int EGL_HORIZONTAL_RESOLUTION = 0x3090;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>EGL_SYNC_PRIOR_COMMANDS_COMPLETE_KHR</code>, <code>EGL_SYNC_PRIOR_COMMANDS_COMPLETE_NV</code><br>
Define "EGL_SYNC_PRIOR_COMMANDS_COMPLETE" with expression '<code>0x30F0</code>', CType: int */
  public static final int EGL_SYNC_PRIOR_COMMANDS_COMPLETE = 0x30f0;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>EGL_SYNC_FENCE_NV</code>, <code>EGL_SYNC_FENCE_KHR</code><br>
Define "EGL_SYNC_FENCE" with expression '<code>0x30F9</code>', CType: int */
  public static final int EGL_SYNC_FENCE = 0x30f9;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_ALLOC" with expression '<code>0x3003</code>', CType: int */
  public static final int EGL_BAD_ALLOC = 0x3003;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_OPENGL_ES_BIT" with expression '<code>0x0001</code>', CType: int */
  public static final int EGL_OPENGL_ES_BIT = 0x1;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NATIVE_VISUAL_ID" with expression '<code>0x302E</code>', CType: int */
  public static final int EGL_NATIVE_VISUAL_ID = 0x302e;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_MAX_PBUFFER_PIXELS" with expression '<code>0x302B</code>', CType: int */
  public static final int EGL_MAX_PBUFFER_PIXELS = 0x302b;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_MAX_SWAP_INTERVAL" with expression '<code>0x303C</code>', CType: int */
  public static final int EGL_MAX_SWAP_INTERVAL = 0x303c;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BUFFER_SIZE" with expression '<code>0x3020</code>', CType: int */
  public static final int EGL_BUFFER_SIZE = 0x3020;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NATIVE_RENDERABLE" with expression '<code>0x302D</code>', CType: int */
  public static final int EGL_NATIVE_RENDERABLE = 0x302d;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_VERSION" with expression '<code>0x3054</code>', CType: int */
  public static final int EGL_VERSION = 0x3054;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_CONFIG_ID" with expression '<code>0x3028</code>', CType: int */
  public static final int EGL_CONFIG_ID = 0x3028;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_LARGEST_PBUFFER" with expression '<code>0x3058</code>', CType: int */
  public static final int EGL_LARGEST_PBUFFER = 0x3058;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRANSPARENT_GREEN_VALUE" with expression '<code>0x3036</code>', CType: int */
  public static final int EGL_TRANSPARENT_GREEN_VALUE = 0x3036;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_MAX_PBUFFER_WIDTH" with expression '<code>0x302C</code>', CType: int */
  public static final int EGL_MAX_PBUFFER_WIDTH = 0x302c;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_HEIGHT" with expression '<code>0x3056</code>', CType: int */
  public static final int EGL_HEIGHT = 0x3056;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_TRANSPARENT_RED_VALUE" with expression '<code>0x3037</code>', CType: int */
  public static final int EGL_TRANSPARENT_RED_VALUE = 0x3037;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_TEXTURE_RGBA" with expression '<code>0x305E</code>', CType: int */
  public static final int EGL_TEXTURE_RGBA = 0x305e;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_ALPHA_SIZE" with expression '<code>0x3021</code>', CType: int */
  public static final int EGL_ALPHA_SIZE = 0x3021;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>EGL_SYNC_CONDITION_KHR</code>, <code>EGL_SYNC_CONDITION_NV</code><br>
Define "EGL_SYNC_CONDITION" with expression '<code>0x30F8</code>', CType: int */
  public static final int EGL_SYNC_CONDITION = 0x30f8;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image_base</code><br>Alias for: <code>EGL_IMAGE_PRESERVED_KHR</code><br>
Define "EGL_IMAGE_PRESERVED" with expression '<code>0x30D2</code>', CType: int */
  public static final int EGL_IMAGE_PRESERVED = 0x30d2;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_2D_image</code><br>Alias for: <code>EGL_GL_TEXTURE_2D_KHR</code><br>
Define "EGL_GL_TEXTURE_2D" with expression '<code>0x30B1</code>', CType: int */
  public static final int EGL_GL_TEXTURE_2D = 0x30b1;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_BAD_NATIVE_WINDOW" with expression '<code>0x300B</code>', CType: int */
  public static final int EGL_BAD_NATIVE_WINDOW = 0x300b;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_PIXMAP_BIT" with expression '<code>0x0002</code>', CType: int */
  public static final int EGL_PIXMAP_BIT = 0x2;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_COLORSPACE_sRGB" with expression '<code>0x3089</code>', CType: int */
  public static final int EGL_COLORSPACE_sRGB = 0x3089;
  /** <code>EGL_VERSION_1_3</code>, <code>EGL_KHR_config_attribs</code><br>Alias for: <code>EGL_VG_ALPHA_FORMAT_PRE_BIT_KHR</code><br>
Define "EGL_VG_ALPHA_FORMAT_PRE_BIT" with expression '<code>0x0040</code>', CType: int */
  public static final int EGL_VG_ALPHA_FORMAT_PRE_BIT = 0x40;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_OPENVG_API" with expression '<code>0x30A1</code>', CType: int */
  public static final int EGL_OPENVG_API = 0x30a1;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NOT_INITIALIZED" with expression '<code>0x3001</code>', CType: int */
  public static final int EGL_NOT_INITIALIZED = 0x3001;
  /** <code>EGL_VERSION_1_3</code><br>Define "EGL_VG_COLORSPACE_sRGB" with expression '<code>0x3089</code>', CType: int */
  public static final int EGL_VG_COLORSPACE_sRGB = 0x3089;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_RED_SIZE" with expression '<code>0x3024</code>', CType: int */
  public static final int EGL_RED_SIZE = 0x3024;
  /** <code>EGL_VERSION_1_1</code><br>Define "EGL_NO_TEXTURE" with expression '<code>0x305C</code>', CType: int */
  public static final int EGL_NO_TEXTURE = 0x305c;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_create_context</code><br>Alias for: <code>EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR</code><br>
Define "EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT" with expression '<code>0x00000002</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT = 0x2;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_OPENVG_BIT" with expression '<code>0x0002</code>', CType: int */
  public static final int EGL_OPENVG_BIT = 0x2;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_SUCCESS" with expression '<code>0x3000</code>', CType: int */
  public static final int EGL_SUCCESS = 0x3000;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_create_context_robustness</code><br>Alias for: <code>EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT</code><br>
Define "EGL_CONTEXT_OPENGL_ROBUST_ACCESS" with expression '<code>0x31B2</code>', CType: int */
  public static final int EGL_CONTEXT_OPENGL_ROBUST_ACCESS = 0x31b2;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_DRAW" with expression '<code>0x3059</code>', CType: int */
  public static final int EGL_DRAW = 0x3059;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_CORE_NATIVE_ENGINE" with expression '<code>0x305B</code>', CType: int */
  public static final int EGL_CORE_NATIVE_ENGINE = 0x305b;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_OPENGL_BIT" with expression '<code>0x0008</code>', CType: int */
  public static final int EGL_OPENGL_BIT = 0x8;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_3D_image</code><br>Alias for: <code>EGL_GL_TEXTURE_3D_KHR</code><br>
Define "EGL_GL_TEXTURE_3D" with expression '<code>0x30B2</code>', CType: int */
  public static final int EGL_GL_TEXTURE_3D = 0x30b2;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_NONE" with expression '<code>0x3038</code>', CType: int */
  public static final int EGL_NONE = 0x3038;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_OPENVG_IMAGE" with expression '<code>0x3096</code>', CType: int */
  public static final int EGL_OPENVG_IMAGE = 0x3096;
  /** <code>EGL_VERSION_1_2</code><br>Define "EGL_RENDERABLE_TYPE" with expression '<code>0x3040</code>', CType: int */
  public static final int EGL_RENDERABLE_TYPE = 0x3040;
  /** <code>EGL_VERSION_1_0</code><br>Define "EGL_VENDOR" with expression '<code>0x3053</code>', CType: int */
  public static final int EGL_VENDOR = 0x3053;
  /** <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_gl_texture_2D_image</code><br>Alias for: <code>EGL_GL_TEXTURE_LEVEL_KHR</code><br>
Define "EGL_GL_TEXTURE_LEVEL" with expression '<code>0x30BC</code>', CType: int */
  public static final int EGL_GL_TEXTURE_LEVEL = 0x30bc;
  /** <code>EGL_VERSION_1_4</code><br>Define "EGL_OPENGL_API" with expression '<code>0x30A2</code>', CType: int */
  public static final int EGL_OPENGL_API = 0x30a2;

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglChooseConfig(long dpy, IntBuffer attrib_list, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglChooseConfig"));
    }
        return dispatch_eglChooseConfig0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglChooseConfig0(long dpy, Object attrib_list, int attrib_list_byte_offset, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglCopyBuffers(long dpy, long surface, long target)  {

    final long __addr_ = _table._addressof_eglCopyBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCopyBuffers"));
    }
        return dispatch_eglCopyBuffers0(dpy, surface, target, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglCopyBuffers0(long dpy, long surface, long target, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreateContext(long dpy, long config, long share_context, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateContext"));
    }
        return dispatch_eglCreateContext0(dpy, config, share_context, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateContext0(long dpy, long config, long share_context, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferSurface(long dpy, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePbufferSurface"));
    }
        return dispatch_eglCreatePbufferSurface0(dpy, config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferSurface0(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code>, <code>EGL_HI_clientpixmap</code><br>Alias for: <code>eglCreatePixmapSurfaceHI</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePixmapSurface(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePixmapSurface"));
    }
        return dispatch_eglCreatePixmapSurface0(dpy, config, pixmap, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code>, <code>EGL_HI_clientpixmap</code><br>Alias for: <code>eglCreatePixmapSurfaceHI</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePixmapSurface0(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreateWindowSurface(long dpy, long config, long win, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateWindowSurface"));
    }
        return dispatch_eglCreateWindowSurface0(dpy, config, win, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateWindowSurface0(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglDestroyContext(long dpy, long ctx)  {

    final long __addr_ = _table._addressof_eglDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyContext"));
    }
        return dispatch_eglDestroyContext0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglDestroyContext0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglDestroySurface(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglDestroySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySurface"));
    }
        return dispatch_eglDestroySurface0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglDestroySurface0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetConfigAttrib"));
    }
        return dispatch_eglGetConfigAttrib0(dpy, config, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigAttrib0(long dpy, long config, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetConfigs"));
    }
        return dispatch_eglGetConfigs0(dpy, configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigs0(long dpy, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static long eglGetCurrentDisplay()  {

    final long __addr_ = _table._addressof_eglGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentDisplay"));
    }
        return dispatch_eglGetCurrentDisplay0(__addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native long dispatch_eglGetCurrentDisplay0(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static long eglGetCurrentSurface(int readdraw)  {

    final long __addr_ = _table._addressof_eglGetCurrentSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentSurface"));
    }
        return dispatch_eglGetCurrentSurface0(readdraw, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native long dispatch_eglGetCurrentSurface0(int readdraw, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static long eglGetDisplay(long display_id)  {

    final long __addr_ = _table._addressof_eglGetDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetDisplay"));
    }
        return dispatch_eglGetDisplay0(display_id, __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native long dispatch_eglGetDisplay0(long display_id, long procAddress);

  /** Entry point to C language function: <code> EGLint eglGetError() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static int eglGetError()  {

    final long __addr_ = _table._addressof_eglGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetError"));
    }
        return dispatch_eglGetError0(__addr_);
  }

  /** Entry point to C language function: <code> EGLint eglGetError() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native int dispatch_eglGetError0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglInitialize(long dpy, IntBuffer major, IntBuffer minor)  {

    if (!Buffers.isDirect(major))
      throw new RuntimeException("Argument \"major\" is not a direct buffer");
    if (!Buffers.isDirect(minor))
      throw new RuntimeException("Argument \"minor\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglInitialize"));
    }
        return dispatch_eglInitialize0(dpy, major, Buffers.getDirectBufferByteOffset(major), minor, Buffers.getDirectBufferByteOffset(minor), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglInitialize0(long dpy, Object major, int major_byte_offset, Object minor, int minor_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglMakeCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _table._addressof_eglMakeCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglMakeCurrent"));
    }
        return dispatch_eglMakeCurrent0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglMakeCurrent0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryContext"));
    }
        return dispatch_eglQueryContext0(dpy, ctx, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQueryContext0(long dpy, long ctx, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static String eglQueryString(long dpy, int name)  {

    final long __addr_ = _table._addressof_eglQueryString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryString"));
    }
        return dispatch_eglQueryString0(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native String dispatch_eglQueryString0(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglQuerySurface(long dpy, long surface, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQuerySurface"));
    }
        return dispatch_eglQuerySurface0(dpy, surface, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQuerySurface0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglSwapBuffers(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglSwapBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffers"));
    }
        return dispatch_eglSwapBuffers0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglSwapBuffers0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglTerminate(long dpy)  {

    final long __addr_ = _table._addressof_eglTerminate;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglTerminate"));
    }
        return dispatch_eglTerminate0(dpy, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglTerminate0(long dpy, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglWaitGL()  {

    final long __addr_ = _table._addressof_eglWaitGL;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitGL"));
    }
        return dispatch_eglWaitGL0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL() </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglWaitGL0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public static boolean eglWaitNative(int engine)  {

    final long __addr_ = _table._addressof_eglWaitNative;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitNative"));
    }
        return dispatch_eglWaitNative0(engine, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  static private native boolean dispatch_eglWaitNative0(int engine, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public static boolean eglBindTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglBindTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglBindTexImage"));
    }
        return dispatch_eglBindTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  static private native boolean dispatch_eglBindTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public static boolean eglReleaseTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglReleaseTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglReleaseTexImage"));
    }
        return dispatch_eglReleaseTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  static private native boolean dispatch_eglReleaseTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public static boolean eglSurfaceAttrib(long dpy, long surface, int attribute, int value)  {

    final long __addr_ = _table._addressof_eglSurfaceAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSurfaceAttrib"));
    }
        return dispatch_eglSurfaceAttrib0(dpy, surface, attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  static private native boolean dispatch_eglSurfaceAttrib0(long dpy, long surface, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public static boolean eglSwapInterval(long dpy, int interval)  {

    final long __addr_ = _table._addressof_eglSwapInterval;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapInterval"));
    }
        return dispatch_eglSwapInterval0(dpy, interval, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  static private native boolean dispatch_eglSwapInterval0(long dpy, int interval, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public static boolean eglBindAPI(int api)  {

    final long __addr_ = _table._addressof_eglBindAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglBindAPI"));
    }
        return dispatch_eglBindAPI0(api, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  static private native boolean dispatch_eglBindAPI0(int api, long procAddress);

  /** Entry point to C language function: <code> EGLenum eglQueryAPI() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public static int eglQueryAPI()  {

    final long __addr_ = _table._addressof_eglQueryAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryAPI"));
    }
        return dispatch_eglQueryAPI0(__addr_);
  }

  /** Entry point to C language function: <code> EGLenum eglQueryAPI() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  static private native int dispatch_eglQueryAPI0(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferFromClientBuffer(long dpy, int buftype, long buffer, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferFromClientBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePbufferFromClientBuffer"));
    }
        return dispatch_eglCreatePbufferFromClientBuffer0(dpy, buftype, buffer, config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferFromClientBuffer0(long dpy, int buftype, long buffer, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public static boolean eglReleaseThread()  {

    final long __addr_ = _table._addressof_eglReleaseThread;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglReleaseThread"));
    }
        return dispatch_eglReleaseThread0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  static private native boolean dispatch_eglReleaseThread0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public static boolean eglWaitClient()  {

    final long __addr_ = _table._addressof_eglWaitClient;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitClient"));
    }
        return dispatch_eglWaitClient0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient() </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  static private native boolean dispatch_eglWaitClient0(long procAddress);

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext() </code> <br>Part of <code>EGL_VERSION_1_4</code><br>   */
  public static long eglGetCurrentContext()  {

    final long __addr_ = _table._addressof_eglGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentContext"));
    }
        return dispatch_eglGetCurrentContext0(__addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext() </code> <br>Part of <code>EGL_VERSION_1_4</code><br>   */
  static private native long dispatch_eglGetCurrentContext0(long procAddress);

  /** Entry point to C language function: <code> EGLSync eglCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglCreateSyncKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long eglCreateSync(long dpy, int type, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateSync"));
    }
        return dispatch_eglCreateSync0(dpy, type, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSync eglCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglCreateSyncKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long dispatch_eglCreateSync0(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySync(EGLDisplay dpy, EGLSync sync) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglDestroySyncKHR</code>, <code>eglDestroySyncNV</code>   */
  public static boolean eglDestroySync(long dpy, long sync)  {

    final long __addr_ = _table._addressof_eglDestroySync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySync"));
    }
        return dispatch_eglDestroySync0(dpy, sync, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySync(EGLDisplay dpy, EGLSync sync) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglDestroySyncKHR</code>, <code>eglDestroySyncNV</code>   */
  static private native boolean dispatch_eglDestroySync0(long dpy, long sync, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglClientWaitSyncKHR</code>, <code>eglClientWaitSyncNV</code>   */
  public static int eglClientWaitSync(long dpy, long sync, int flags, long timeout)  {

    final long __addr_ = _table._addressof_eglClientWaitSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSync"));
    }
        return dispatch_eglClientWaitSync0(dpy, sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglClientWaitSyncKHR</code>, <code>eglClientWaitSyncNV</code>   */
  static private native int dispatch_eglClientWaitSync0(long dpy, long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglGetSyncAttribNV</code>, <code>eglGetSyncAttribKHR</code>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean eglGetSyncAttrib(long dpy, long sync, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetSyncAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttrib"));
    }
        return dispatch_eglGetSyncAttrib0(dpy, sync, attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglGetSyncAttribNV</code>, <code>eglGetSyncAttribKHR</code>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean dispatch_eglGetSyncAttrib0(long dpy, long sync, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLImage eglCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglCreateImageKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long eglCreateImage(long dpy, long ctx, int target, long buffer, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateImage"));
    }
        return dispatch_eglCreateImage0(dpy, ctx, target, buffer, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImage eglCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglCreateImageKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long dispatch_eglCreateImage0(long dpy, long ctx, int target, long buffer, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImage(EGLDisplay dpy, EGLImage image) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglDestroyImageKHR</code>   */
  public static boolean eglDestroyImage(long dpy, long image)  {

    final long __addr_ = _table._addressof_eglDestroyImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyImage"));
    }
        return dispatch_eglDestroyImage0(dpy, image, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImage(EGLDisplay dpy, EGLImage image) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglDestroyImageKHR</code>   */
  static private native boolean dispatch_eglDestroyImage0(long dpy, long image, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplay(EGLenum platform, void *  native_display, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglGetPlatformDisplayEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long eglGetPlatformDisplay(int platform, long native_display, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetPlatformDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetPlatformDisplay"));
    }
        return dispatch_eglGetPlatformDisplay0(platform, native_display, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplay(EGLenum platform, void *  native_display, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglGetPlatformDisplayEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long dispatch_eglGetPlatformDisplay0(int platform, long native_display, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformWindowSurfaceEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long eglCreatePlatformWindowSurface(long dpy, long config, long native_window, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformWindowSurface"));
    }
        return dispatch_eglCreatePlatformWindowSurface0(dpy, config, native_window, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformWindowSurfaceEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long dispatch_eglCreatePlatformWindowSurface0(long dpy, long config, long native_window, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformPixmapSurfaceEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long eglCreatePlatformPixmapSurface(long dpy, long config, long native_pixmap, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformPixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformPixmapSurface"));
    }
        return dispatch_eglCreatePlatformPixmapSurface0(dpy, config, native_pixmap, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformPixmapSurfaceEXT</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long dispatch_eglCreatePlatformPixmapSurface0(long dpy, long config, long native_pixmap, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_wait_sync</code><br>Alias for: <code>eglWaitSyncKHR</code>   */
  public static boolean eglWaitSync(long dpy, long sync, int flags)  {

    final long __addr_ = _table._addressof_eglWaitSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitSync"));
    }
        return dispatch_eglWaitSync0(dpy, sync, flags, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_wait_sync</code><br>Alias for: <code>eglWaitSyncKHR</code>   */
  static private native boolean dispatch_eglWaitSync0(long dpy, long sync, int flags, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 /** Defined as part of enum type "khronos_boolean_enum_t" - CType: int */
 public static final long KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7fffffff;
  
      private static EGLProcAddressTable _table = new EGLProcAddressTable(new GLProcAddressResolver());
      protected static boolean resetProcAddressTable(DynamicLookupHelper lookup) {
          _table.reset(lookup);
          return 0 != _table._addressof_eglGetDisplay && 0 != _table._addressof_eglInitialize;
      }
  
      // There are some #defines in egl.h that GlueGen and PCPP don't currently handle
      public static final long EGL_DEFAULT_DISPLAY = 0;
      public static final long EGL_NO_CONTEXT = 0;
      public static final long EGL_NO_DISPLAY = 0;
      public static final long EGL_NO_SURFACE = 0;
      public static final int  EGL_DONT_CARE  = -1;
      public static final int  EGL_UNKNOWN    = -1;
  
      /** 
       * In case of an error on a particualr attribute, the attribute in the attributes-buffer is set to 0.
       * <p>
       * Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_0</code>
       * </p>
       */
      public static void eglGetConfigAttributes(long dpy, long config, IntBuffer attributes, IntBuffer values) {
          if( attributes == null || values == null ) {
              throw new RuntimeException("arrays buffers are null");
          }
          if( !Buffers.isDirect(attributes) || !Buffers.isDirect(values) ) {
              throw new RuntimeException("arrays buffers are not direct");
          }
          if( attributes.remaining() > values.remaining() ) {
              throw new RuntimeException("not enough values "+values+" for attributes "+attributes);
          }
          final long __addr = _table._addressof_eglGetConfigAttrib;
          dispatch_eglGetConfigAttributes(dpy, config, attributes.remaining(), attributes, Buffers.getDirectBufferByteOffset(attributes), 
                                          values, Buffers.getDirectBufferByteOffset(values), __addr);
      }
      private static native void dispatch_eglGetConfigAttributes(long dpy, long config, int attributeCount, Object attributes, int attributes_byte_offset, Object values, int valuesOffset, long procAddr);
  
  // ---- End CustomJavaCode .cfg declarations
} // end of class EGL
