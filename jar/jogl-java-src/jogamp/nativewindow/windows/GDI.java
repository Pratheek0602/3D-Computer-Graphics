/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Fri Aug 18 14:57:06 CEST 2023 ----! */
/* !---- Java-Unit: [pkg jogamp.nativewindow.windows, cls GDI], ../build/nativewindow/gensrc/classes/jogamp/nativewindow/windows/GDI.java ----! */

package jogamp.nativewindow.windows;

import com.jogamp.nativewindow.util.Point;
import com.jogamp.nativewindow.NativeWindowException;
import jogamp.nativewindow.NWJNILibLoader;
import jogamp.nativewindow.Debug;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;
import com.jogamp.common.util.*;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class GDI {

  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>1</code>', CType: int */
  public static final int DWMWA_NCRENDERING_ENABLED = 0x1;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x2</code>', CType: int */
  public static final int DWMWA_NCRENDERING_POLICY = 0x2;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x3</code>', CType: int */
  public static final int DWMWA_TRANSITIONS_FORCEDISABLED = 0x3;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x4</code>', CType: int */
  public static final int DWMWA_ALLOW_NCPAINT = 0x4;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x5</code>', CType: int */
  public static final int DWMWA_CAPTION_BUTTON_BOUNDS = 0x5;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x6</code>', CType: int */
  public static final int DWMWA_NONCLIENT_RTL_LAYOUT = 0x6;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x7</code>', CType: int */
  public static final int DWMWA_FORCE_ICONIC_REPRESENTATION = 0x7;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x8</code>', CType: int */
  public static final int DWMWA_FLIP3D_POLICY = 0x8;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x9</code>', CType: int */
  public static final int DWMWA_EXTENDED_FRAME_BOUNDS = 0x9;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xa</code>', CType: int */
  public static final int DWMWA_HAS_ICONIC_BITMAP = 0xa;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xb</code>', CType: int */
  public static final int DWMWA_DISALLOW_PEEK = 0xb;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xc</code>', CType: int */
  public static final int DWMWA_EXCLUDED_FROM_PEEK = 0xc;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xd</code>', CType: int */
  public static final int DWMWA_CLOAK = 0xd;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xe</code>', CType: int */
  public static final int DWMWA_CLOAKED = 0xe;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0xf</code>', CType: int */
  public static final int DWMWA_FREEZE_REPRESENTATION = 0xf;
  /** Defined as part of enum type "DWMWINDOWATTRIBUTE" with expression '<code>0x10</code>', CType: int */
  public static final int DWMWA_LAST = 0x10;
  /** Defined as part of enum type "AccentState" with expression '<code>0</code>', CType: int */
  public static final int ACCENT_DISABLED = 0x0;
  /** Defined as part of enum type "AccentState" with expression '<code>1</code>', CType: int */
  public static final int ACCENT_ENABLE_GRADIENT = 0x1;
  /** Defined as part of enum type "AccentState" with expression '<code>2</code>', CType: int */
  public static final int ACCENT_ENABLE_TRANSPARENTGRADIENT = 0x2;
  /** Defined as part of enum type "AccentState" with expression '<code>3</code>', CType: int */
  public static final int ACCENT_ENABLE_BLURBEHIND = 0x3;
  /** Defined as part of enum type "AccentState" with expression '<code>4</code>', CType: int */
  public static final int ACCENT_INVALID_STATE = 0x4;
  /** Defined as part of enum type "DWMNCRENDERINGPOLICY" with expression '<code>0</code>', CType: int */
  public static final int DWMNCRP_USEWINDOWSTYLE = 0x0;
  /** Defined as part of enum type "DWMNCRENDERINGPOLICY" with expression '<code>0x1</code>', CType: int */
  public static final int DWMNCRP_DISABLED = 0x1;
  /** Defined as part of enum type "DWMNCRENDERINGPOLICY" with expression '<code>0x2</code>', CType: int */
  public static final int DWMNCRP_ENABLED = 0x2;
  /** Defined as part of enum type "DWMNCRENDERINGPOLICY" with expression '<code>0x3</code>', CType: int */
  public static final int DWMNCRP_LAST = 0x3;
  /** Define "OBJ_METADC" with expression '<code>4</code>', CType: int */
  public static final int OBJ_METADC = 0x4;
  /** Define "SW_SHOW" with expression '<code>5</code>', CType: int */
  public static final int SW_SHOW = 0x5;
  /** Define "SW_SHOWDEFAULT" with expression '<code>10</code>', CType: int */
  public static final int SW_SHOWDEFAULT = 0xa;
  /** Define "PFD_STEREO" with expression '<code>0x00000002</code>', CType: int */
  public static final int PFD_STEREO = 0x2;
  /** Define "PFD_SUPPORT_DIRECTDRAW" with expression '<code>0x00002000</code>', CType: int */
  public static final int PFD_SUPPORT_DIRECTDRAW = 0x2000;
  /** Define "DIB_PAL_COLORS" with expression '<code>1</code>', CType: int */
  public static final int DIB_PAL_COLORS = 0x1;
  /** Define "BI_RLE8" with expression '<code>1</code>', CType: int */
  public static final int BI_RLE8 = 0x1;
  /** Define "PFD_GENERIC_ACCELERATED" with expression '<code>0x00001000</code>', CType: int */
  public static final int PFD_GENERIC_ACCELERATED = 0x1000;
  /** Define "BI_RLE4" with expression '<code>2</code>', CType: int */
  public static final int BI_RLE4 = 0x2;
  /** Define "OBJ_ENHMETAFILE" with expression '<code>13</code>', CType: int */
  public static final int OBJ_ENHMETAFILE = 0xd;
  /** Define "SW_FORCEMINIMIZE" with expression '<code>11</code>', CType: int */
  public static final int SW_FORCEMINIMIZE = 0xb;
  /** Define "ERROR_SUCCESS" with expression '<code>0</code>', CType: int */
  public static final int ERROR_SUCCESS = 0x0;
  /** Define "ERROR_INVALID_DATA" with expression '<code>13</code>', CType: int */
  public static final int ERROR_INVALID_DATA = 0xd;
  /** Define "PFD_UNDERLAY_PLANE" with expression '<code>(-1)</code>', CType: int */
  public static final int PFD_UNDERLAY_PLANE = ( - 0x1 );
  /** Define "DWM_EC_ENABLECOMPOSITION" with expression '<code>1</code>', CType: int */
  public static final int DWM_EC_ENABLECOMPOSITION = 0x1;
  /** Define "DWM_BB_BLURREGION" with expression '<code>0x00000002</code>', CType: int */
  public static final int DWM_BB_BLURREGION = 0x2;
  /** Define "SW_NORMAL" with expression '<code>1</code>', CType: int */
  public static final int SW_NORMAL = 0x1;
  /** Define "ERROR_INVALID_WINDOW_HANDLE" with expression '<code>1400</code>', CType: int */
  public static final int ERROR_INVALID_WINDOW_HANDLE = 0x578;
  /** Define "DIB_RGB_COLORS" with expression '<code>0</code>', CType: int */
  public static final int DIB_RGB_COLORS = 0x0;
  /** Define "ERROR_NO_SYSTEM_RESOURCES" with expression '<code>1450</code>', CType: int */
  public static final int ERROR_NO_SYSTEM_RESOURCES = 0x5aa;
  /** Define "BI_BITFIELDS" with expression '<code>3</code>', CType: int */
  public static final int BI_BITFIELDS = 0x3;
  /** Define "PFD_MAIN_PLANE" with expression '<code>0</code>', CType: int */
  public static final int PFD_MAIN_PLANE = 0x0;
  /** Define "DWM_EC_DISABLECOMPOSITION" with expression '<code>0</code>', CType: int */
  public static final int DWM_EC_DISABLECOMPOSITION = 0x0;
  /** Define "OBJ_BRUSH" with expression '<code>2</code>', CType: int */
  public static final int OBJ_BRUSH = 0x2;
  /** Define "PFD_DEPTH_DONTCARE" with expression '<code>0x20000000</code>', CType: int */
  public static final int PFD_DEPTH_DONTCARE = 0x20000000;
  /** Define "PFD_SUPPORT_GDI" with expression '<code>0x00000010</code>', CType: int */
  public static final int PFD_SUPPORT_GDI = 0x10;
  /** Define "PFD_STEREO_DONTCARE" with expression '<code>0x80000000</code>', CType: long */
  public static final long PFD_STEREO_DONTCARE = 0x80000000L;
  /** Define "OBJ_BITMAP" with expression '<code>7</code>', CType: int */
  public static final int OBJ_BITMAP = 0x7;
  /** Define "SW_SHOWMINNOACTIVE" with expression '<code>7</code>', CType: int */
  public static final int SW_SHOWMINNOACTIVE = 0x7;
  /** Define "OBJ_COLORSPACE" with expression '<code>14</code>', CType: int */
  public static final int OBJ_COLORSPACE = 0xe;
  /** Define "SW_MINIMIZE" with expression '<code>6</code>', CType: int */
  public static final int SW_MINIMIZE = 0x6;
  /** Define "OBJ_MEMDC" with expression '<code>10</code>', CType: int */
  public static final int OBJ_MEMDC = 0xa;
  /** Define "PFD_SWAP_COPY" with expression '<code>0x00000400</code>', CType: int */
  public static final int PFD_SWAP_COPY = 0x400;
  /** Define "PFD_TYPE_COLORINDEX" with expression '<code>1</code>', CType: int */
  public static final int PFD_TYPE_COLORINDEX = 0x1;
  /** Define "SW_SHOWNORMAL" with expression '<code>1</code>', CType: int */
  public static final int SW_SHOWNORMAL = 0x1;
  /** Define "PFD_NEED_SYSTEM_PALETTE" with expression '<code>0x00000100</code>', CType: int */
  public static final int PFD_NEED_SYSTEM_PALETTE = 0x100;
  /** Define "SW_MAXIMIZE" with expression '<code>3</code>', CType: int */
  public static final int SW_MAXIMIZE = 0x3;
  /** Define "SW_RESTORE" with expression '<code>9</code>', CType: int */
  public static final int SW_RESTORE = 0x9;
  /** Define "PFD_SUPPORT_OPENGL" with expression '<code>0x00000020</code>', CType: int */
  public static final int PFD_SUPPORT_OPENGL = 0x20;
  /** Define "SW_HIDE" with expression '<code>0</code>', CType: int */
  public static final int SW_HIDE = 0x0;
  /** Define "OBJ_FONT" with expression '<code>6</code>', CType: int */
  public static final int OBJ_FONT = 0x6;
  /** Define "PFD_SWAP_EXCHANGE" with expression '<code>0x00000200</code>', CType: int */
  public static final int PFD_SWAP_EXCHANGE = 0x200;
  /** Define "SW_SHOWNA" with expression '<code>8</code>', CType: int */
  public static final int SW_SHOWNA = 0x8;
  /** Define "PFD_DRAW_TO_BITMAP" with expression '<code>0x00000008</code>', CType: int */
  public static final int PFD_DRAW_TO_BITMAP = 0x8;
  /** Define "OBJ_EXTPEN" with expression '<code>11</code>', CType: int */
  public static final int OBJ_EXTPEN = 0xb;
  /** Define "PFD_NEED_PALETTE" with expression '<code>0x00000080</code>', CType: int */
  public static final int PFD_NEED_PALETTE = 0x80;
  /** Define "ERROR_PROC_NOT_FOUND" with expression '<code>127</code>', CType: int */
  public static final int ERROR_PROC_NOT_FOUND = 0x7f;
  /** Define "OBJ_METAFILE" with expression '<code>9</code>', CType: int */
  public static final int OBJ_METAFILE = 0x9;
  /** Define "PFD_SWAP_LAYER_BUFFERS" with expression '<code>0x00000800</code>', CType: int */
  public static final int PFD_SWAP_LAYER_BUFFERS = 0x800;
  /** Define "PFD_DOUBLEBUFFER" with expression '<code>0x00000001</code>', CType: int */
  public static final int PFD_DOUBLEBUFFER = 0x1;
  /** Define "PFD_DRAW_TO_WINDOW" with expression '<code>0x00000004</code>', CType: int */
  public static final int PFD_DRAW_TO_WINDOW = 0x4;
  /** Define "SW_SHOWNOACTIVATE" with expression '<code>4</code>', CType: int */
  public static final int SW_SHOWNOACTIVATE = 0x4;
  /** Define "OBJ_ENHMETADC" with expression '<code>12</code>', CType: int */
  public static final int OBJ_ENHMETADC = 0xc;
  /** Define "BI_RGB" with expression '<code>0</code>', CType: int */
  public static final int BI_RGB = 0x0;
  /** Define "DWM_BB_TRANSITIONONMAXIMIZED" with expression '<code>0x00000004</code>', CType: int */
  public static final int DWM_BB_TRANSITIONONMAXIMIZED = 0x4;
  /** Define "SW_SHOWMINIMIZED" with expression '<code>2</code>', CType: int */
  public static final int SW_SHOWMINIMIZED = 0x2;
  /** Define "PFD_DOUBLEBUFFER_DONTCARE" with expression '<code>0x40000000</code>', CType: int */
  public static final int PFD_DOUBLEBUFFER_DONTCARE = 0x40000000;
  /** Define "OBJ_REGION" with expression '<code>8</code>', CType: int */
  public static final int OBJ_REGION = 0x8;
  /** Define "SW_MAX" with expression '<code>11</code>', CType: int */
  public static final int SW_MAX = 0xb;
  /** Define "OBJ_DC" with expression '<code>3</code>', CType: int */
  public static final int OBJ_DC = 0x3;
  /** Define "PFD_OVERLAY_PLANE" with expression '<code>1</code>', CType: int */
  public static final int PFD_OVERLAY_PLANE = 0x1;
  /** Define "PFD_GENERIC_FORMAT" with expression '<code>0x00000040</code>', CType: int */
  public static final int PFD_GENERIC_FORMAT = 0x40;
  /** Define "OBJ_PAL" with expression '<code>5</code>', CType: int */
  public static final int OBJ_PAL = 0x5;
  /** Define "ERROR_INVALID_PIXEL_FORMAT" with expression '<code>2000</code>', CType: int */
  public static final int ERROR_INVALID_PIXEL_FORMAT = 0x7d0;
  /** Define "OBJ_PEN" with expression '<code>1</code>', CType: int */
  public static final int OBJ_PEN = 0x1;
  /** Define "SW_SHOWMAXIMIZED" with expression '<code>3</code>', CType: int */
  public static final int SW_SHOWMAXIMIZED = 0x3;
  /** Define "PFD_TYPE_RGBA" with expression '<code>0</code>', CType: int */
  public static final int PFD_TYPE_RGBA = 0x0;
  /** Define "DWM_BB_ENABLE" with expression '<code>0x00000001</code>', CType: int */
  public static final int DWM_BB_ENABLE = 0x1;

  /** Interface to C language function: <br> <code>DWORD GetLastError()</code><br>   */
  public static native int GetLastError();

  /** Interface to C language function: <br> <code>int ChoosePixelFormat(HDC, const PIXELFORMATDESCRIPTOR * )</code><br>   */
  public static int ChoosePixelFormat(long arg0, PIXELFORMATDESCRIPTOR arg1)  {

        return ChoosePixelFormat1(arg0, ((arg1 == null) ? null : arg1.getBuffer()));
  }

  /** Entry point to C language function: <code>int ChoosePixelFormat(HDC, const PIXELFORMATDESCRIPTOR * )</code><br>   */
  private static native int ChoosePixelFormat1(long arg0, ByteBuffer arg1);

  /** Interface to C language function: <br> <code>int DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR)</code><br>   */
  public static int DescribePixelFormat(long arg0, int arg1, int arg2, PIXELFORMATDESCRIPTOR arg3)  {

        return DescribePixelFormat1(arg0, arg1, arg2, ((arg3 == null) ? null : arg3.getBuffer()));
  }

  /** Entry point to C language function: <code>int DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR)</code><br>   */
  private static native int DescribePixelFormat1(long arg0, int arg1, int arg2, ByteBuffer arg3);

  /** Interface to C language function: <br> <code>int GetPixelFormat(HDC)</code><br>   */
  public static native int GetPixelFormat(long arg0);

  /** Interface to C language function: <br> <code>BOOL SetPixelFormat(HDC, int, const PIXELFORMATDESCRIPTOR * )</code><br>   */
  public static boolean SetPixelFormat(long arg0, int arg1, PIXELFORMATDESCRIPTOR arg2)  {

        return SetPixelFormat1(arg0, arg1, ((arg2 == null) ? null : arg2.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL SetPixelFormat(HDC, int, const PIXELFORMATDESCRIPTOR * )</code><br>   */
  private static native boolean SetPixelFormat1(long arg0, int arg1, ByteBuffer arg2);

  /** Interface to C language function: <br> <code>BOOL SwapBuffers(HDC)</code><br>   */
  public static native boolean SwapBuffers(long arg0);

  /** Interface to C language function: <br> <code>HDC CreateCompatibleDC(HDC)</code><br>   */
  public static native long CreateCompatibleDC(long arg0);

  /** Interface to C language function: <br> <code>HBITMAP CreateDIBSection(HDC, const BITMAPINFO * , UINT, void *  * , HANDLE, DWORD)</code><br>
      @param arg3 a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long CreateDIBSection(long arg0, BITMAPINFO arg1, int arg2, PointerBuffer arg3, long arg4, int arg5)  {

    final boolean arg3_is_direct = Buffers.isDirect(arg3);
        return CreateDIBSection1(arg0, ((arg1 == null) ? null : arg1.getBuffer()), arg2, arg3_is_direct ? ( arg3 != null ? arg3.getBuffer() : null ) : Buffers.getArray(arg3), arg3_is_direct ? Buffers.getDirectBufferByteOffset(arg3) : Buffers.getIndirectBufferByteOffset(arg3), arg3_is_direct, arg4, arg5);
  }

  /** Entry point to C language function: <code>HBITMAP CreateDIBSection(HDC, const BITMAPINFO * , UINT, void *  * , HANDLE, DWORD)</code><br>
      @param arg3 a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long CreateDIBSection1(long arg0, ByteBuffer arg1, int arg2, Object arg3, int arg3_byte_offset, boolean arg3_is_direct, long arg4, int arg5);

  /** Interface to C language function: <br> <code>BOOL DeleteDC(HDC)</code><br>   */
  public static native boolean DeleteDC(long arg0);

  /** Interface to C language function: <br> <code>BOOL DeleteObject(HGDIOBJ)</code><br>   */
  public static native boolean DeleteObject(long arg0);

  /** Interface to C language function: <br> <code>HGDIOBJ SelectObject(HDC, HGDIOBJ)</code><br>   */
  public static native long SelectObject(long arg0, long arg1);

  /** Interface to C language function: <br> <code>HINSTANCE GetApplicationHandle()</code><br>   */
  public static native long GetApplicationHandle();

  /** Interface to C language function: <br> <code>BOOL ShowWindow(HWND hWnd, int nCmdShow)</code><br>   */
  public static native boolean ShowWindow(long hWnd, int nCmdShow);

  /** Interface to C language function: <br> <code>HDC GetDC(HWND)</code><br>   */
  public static native long GetDC(long arg0);

  /** Interface to C language function: <br> <code>int ReleaseDC(HWND hWnd, HDC hDC)</code><br>   */
  public static native int ReleaseDC(long hWnd, long hDC);

  /** Interface to C language function: <br> <code>HWND WindowFromDC(HDC hDC)</code><br>   */
  public static native long WindowFromDC(long hDC);

  /** Interface to C language function: <br> <code>BOOL GetClientRect(HWND hwnd, LPRECT lpRect)</code><br>   */
  public static boolean GetClientRect(long hwnd, RECT lpRect)  {

        return GetClientRect1(hwnd, ((lpRect == null) ? null : lpRect.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL GetClientRect(HWND hwnd, LPRECT lpRect)</code><br>   */
  private static native boolean GetClientRect1(long hwnd, ByteBuffer lpRect);

  /** Interface to C language function: <br> <code>BOOL DestroyWindow(HWND hWnd)</code><br>   */
  public static native boolean DestroyWindow(long hWnd);

  /** Interface to C language function: <br> <code>DWORD GetObjectType(HGDIOBJ h)</code><br>   */
  public static native int GetObjectType(long h);

  /** Interface to C language function: <br> <code>BOOL IsWindowVisible(HWND hWnd)</code><br>   */
  public static native boolean IsWindowVisible(long hWnd);

  /** Interface to C language function: <br> <code>BOOL IsWindow(HWND hWnd)</code><br>   */
  public static native boolean IsWindow(long hWnd);

  /** Interface to C language function: <br> <code>HWND GetParent(HWND hWnd)</code><br>   */
  public static native long GetParent(long hWnd);

  /** Interface to C language function: <br> <code>HWND SetParent(HWND hWndChild, HWND hWndNewParent)</code><br>   */
  public static native long SetParent(long hWndChild, long hWndNewParent);

  /** Interface to C language function: <br> <code>HANDLE GetCurrentProcess()</code><br>   */
  public static native long GetCurrentProcess();

  /** Interface to C language function: <br> <code>HANDLE GetCurrentThread()</code><br>   */
  public static native long GetCurrentThread();

  /** Interface to C language function: <br> <code>BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)</code><br>
      @param lpProcessAffinityMask a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param lpSystemAffinityMask a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean GetProcessAffinityMask(long hProcess, PointerBuffer lpProcessAffinityMask, PointerBuffer lpSystemAffinityMask)  {

    final boolean lpProcessAffinityMask_is_direct = Buffers.isDirect(lpProcessAffinityMask);
    final boolean lpSystemAffinityMask_is_direct = Buffers.isDirect(lpSystemAffinityMask);
        return GetProcessAffinityMask1(hProcess, lpProcessAffinityMask_is_direct ? ( lpProcessAffinityMask != null ? lpProcessAffinityMask.getBuffer() : null ) : Buffers.getArray(lpProcessAffinityMask), lpProcessAffinityMask_is_direct ? Buffers.getDirectBufferByteOffset(lpProcessAffinityMask) : Buffers.getIndirectBufferByteOffset(lpProcessAffinityMask), lpProcessAffinityMask_is_direct, lpSystemAffinityMask_is_direct ? ( lpSystemAffinityMask != null ? lpSystemAffinityMask.getBuffer() : null ) : Buffers.getArray(lpSystemAffinityMask), lpSystemAffinityMask_is_direct ? Buffers.getDirectBufferByteOffset(lpSystemAffinityMask) : Buffers.getIndirectBufferByteOffset(lpSystemAffinityMask), lpSystemAffinityMask_is_direct);
  }

  /** Entry point to C language function: <code>BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)</code><br>
      @param lpProcessAffinityMask a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param lpSystemAffinityMask a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean GetProcessAffinityMask1(long hProcess, Object lpProcessAffinityMask, int lpProcessAffinityMask_byte_offset, boolean lpProcessAffinityMask_is_direct, Object lpSystemAffinityMask, int lpSystemAffinityMask_byte_offset, boolean lpSystemAffinityMask_is_direct);

  /** Interface to C language function: <br> <code>BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)</code><br>   */
  public static native boolean SetProcessAffinityMask(long hProcess, long dwProcessAffinityMask);

  /** Interface to C language function: <br> <code>DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)</code><br>   */
  public static native long SetThreadAffinityMask(long hThread, long dwThreadAffinityMask);

  /** Interface to C language function: <br> <code>BOOL GetDeviceGammaRamp(HDC, LPVOID)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.Buffer}   */
  public static boolean GetDeviceGammaRamp(long arg0, Buffer arg1)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
        return GetDeviceGammaRamp1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct);
  }

  /** Entry point to C language function: <code>BOOL GetDeviceGammaRamp(HDC, LPVOID)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.Buffer}   */
  private static native boolean GetDeviceGammaRamp1(long arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct);

  /** Interface to C language function: <br> <code>BOOL SetDeviceGammaRamp(HDC, LPVOID)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.Buffer}   */
  public static boolean SetDeviceGammaRamp(long arg0, Buffer arg1)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
        return SetDeviceGammaRamp1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct);
  }

  /** Entry point to C language function: <code>BOOL SetDeviceGammaRamp(HDC, LPVOID)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.Buffer}   */
  private static native boolean SetDeviceGammaRamp1(long arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct);

  /** Interface to C language function: <br> <code>HMONITOR GetMonitorFromWindow(HWND hwnd)</code><br>   */
  public static native long GetMonitorFromWindow(long hwnd);

  /** Interface to C language function: <br> <code>HMONITOR GetMonitorFromPoint(int x, int y)</code><br>   */
  public static native long GetMonitorFromPoint(int x, int y);

  /** Interface to C language function: <br> <code>HMONITOR GetMonitorFromRect(int left, int top, int right, int bottom)</code><br>   */
  public static native long GetMonitorFromRect(int left, int top, int right, int bottom);

  /** Interface to C language function: <br> <code>BOOL DwmIsExtensionAvailable()</code><br>   */
  public static native boolean DwmIsExtensionAvailable();

  /** Interface to C language function: <br> <code>BOOL DwmIsCompositionEnabled()</code><br>   */
  public static native boolean DwmIsCompositionEnabled();

  /** Interface to C language function: <br> <code>BOOL DwmEnableComposition(UINT uCompositionAction)</code><br>   */
  public static native boolean DwmEnableComposition(int uCompositionAction);

  /** Interface to C language function: <br> <code>BOOL DwmEnableBlurBehindWindow(HWND, const DWM_BLURBEHIND * )</code><br>   */
  public static boolean DwmEnableBlurBehindWindow(long arg0, DWM_BLURBEHIND arg1)  {

        return DwmEnableBlurBehindWindow0(arg0, ((arg1 == null) ? null : arg1.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL DwmEnableBlurBehindWindow(HWND, const DWM_BLURBEHIND * )</code><br>   */
  private static native boolean DwmEnableBlurBehindWindow0(long arg0, ByteBuffer arg1);

  /** Interface to C language function: <br> <code>BOOL DwmExtendFrameIntoClientArea(HWND, const MARGINS * )</code><br>   */
  public static boolean DwmExtendFrameIntoClientArea(long arg0, MARGINS arg1)  {

        return DwmExtendFrameIntoClientArea0(arg0, ((arg1 == null) ? null : arg1.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL DwmExtendFrameIntoClientArea(HWND, const MARGINS * )</code><br>   */
  private static native boolean DwmExtendFrameIntoClientArea0(long arg0, ByteBuffer arg1);

  /** Interface to C language function: <br> <code>HRESULT DwmGetWindowAttribute(HWND hwnd, DWORD dwAttribute, PVOID pvAttribute, DWORD cbAttribute)</code><br>
      @param pvAttribute a direct only {@link java.nio.Buffer}   */
  public static int DwmGetWindowAttribute(long hwnd, int dwAttribute, Buffer pvAttribute, int cbAttribute)  {

    if (!Buffers.isDirect(pvAttribute))
      throw new RuntimeException("Argument \"pvAttribute\" is not a direct buffer");
        return DwmGetWindowAttribute0(hwnd, dwAttribute, pvAttribute, Buffers.getDirectBufferByteOffset(pvAttribute), cbAttribute);
  }

  /** Entry point to C language function: <code>HRESULT DwmGetWindowAttribute(HWND hwnd, DWORD dwAttribute, PVOID pvAttribute, DWORD cbAttribute)</code><br>
      @param pvAttribute a direct only {@link java.nio.Buffer}   */
  private static native int DwmGetWindowAttribute0(long hwnd, int dwAttribute, Object pvAttribute, int pvAttribute_byte_offset, int cbAttribute);

  /** Interface to C language function: <br> <code>HRESULT DwmSetWindowAttribute(HWND hwnd, DWORD dwAttribute, LPCVOID pvAttribute, DWORD cbAttribute)</code><br>
      @param pvAttribute a direct only {@link java.nio.Buffer}   */
  public static int DwmSetWindowAttribute(long hwnd, int dwAttribute, Buffer pvAttribute, int cbAttribute)  {

    if (!Buffers.isDirect(pvAttribute))
      throw new RuntimeException("Argument \"pvAttribute\" is not a direct buffer");
        return DwmSetWindowAttribute0(hwnd, dwAttribute, pvAttribute, Buffers.getDirectBufferByteOffset(pvAttribute), cbAttribute);
  }

  /** Entry point to C language function: <code>HRESULT DwmSetWindowAttribute(HWND hwnd, DWORD dwAttribute, LPCVOID pvAttribute, DWORD cbAttribute)</code><br>
      @param pvAttribute a direct only {@link java.nio.Buffer}   */
  private static native int DwmSetWindowAttribute0(long hwnd, int dwAttribute, Object pvAttribute, int pvAttribute_byte_offset, int cbAttribute);

  /** Interface to C language function: <br> <code>BOOL IsWindowCompositionExtensionAvailable()</code><br>   */
  public static native boolean IsWindowCompositionExtensionAvailable();

  /** Interface to C language function: <br> <code>BOOL GetWindowCompositionAccentPolicy(HWND hwnd, AccentPolicy *  pAccentPolicy)</code><br>   */
  public static boolean GetWindowCompositionAccentPolicy(long hwnd, AccentPolicy pAccentPolicy)  {

        return GetWindowCompositionAccentPolicy0(hwnd, ((pAccentPolicy == null) ? null : pAccentPolicy.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL GetWindowCompositionAccentPolicy(HWND hwnd, AccentPolicy *  pAccentPolicy)</code><br>   */
  private static native boolean GetWindowCompositionAccentPolicy0(long hwnd, ByteBuffer pAccentPolicy);

  /** Interface to C language function: <br> <code>BOOL SetWindowCompositionAccentPolicy(HWND hwnd, const AccentPolicy *  pAccentPolicy)</code><br>   */
  public static boolean SetWindowCompositionAccentPolicy(long hwnd, AccentPolicy pAccentPolicy)  {

        return SetWindowCompositionAccentPolicy0(hwnd, ((pAccentPolicy == null) ? null : pAccentPolicy.getBuffer()));
  }

  /** Entry point to C language function: <code>BOOL SetWindowCompositionAccentPolicy(HWND hwnd, const AccentPolicy *  pAccentPolicy)</code><br>   */
  private static native boolean SetWindowCompositionAccentPolicy0(long hwnd, ByteBuffer pAccentPolicy);

  /** Interface to C language function: <br> <code>BOOL ShcIsExtensionAvailable()</code><br>   */
  public static native boolean ShcIsExtensionAvailable();

  /** Interface to C language function: <br> <code>BOOL ShcGetMonitorPixelScale1(HMONITOR hmon, float *  psXY)</code><br>
      @param psXY a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static boolean ShcGetMonitorPixelScale1(long hmon, FloatBuffer psXY)  {

    final boolean psXY_is_direct = Buffers.isDirect(psXY);
        return ShcGetMonitorPixelScale11(hmon, psXY_is_direct ? psXY : Buffers.getArray(psXY), psXY_is_direct ? Buffers.getDirectBufferByteOffset(psXY) : Buffers.getIndirectBufferByteOffset(psXY), psXY_is_direct);
  }

  /** Entry point to C language function: <code>BOOL ShcGetMonitorPixelScale1(HMONITOR hmon, float *  psXY)</code><br>
      @param psXY a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native boolean ShcGetMonitorPixelScale11(long hmon, Object psXY, int psXY_byte_offset, boolean psXY_is_direct);

  /** Interface to C language function: <br> <code>BOOL ShcGetMonitorPixelScale1(HMONITOR hmon, float *  psXY)</code><br>   */
  public static boolean ShcGetMonitorPixelScale1(long hmon, float[] psXY, int psXY_offset)  {

    if(psXY != null && psXY.length <= psXY_offset)
      throw new RuntimeException("array offset argument \"psXY_offset\" (" + psXY_offset + ") equals or exceeds array length (" + psXY.length + ")");
        return ShcGetMonitorPixelScale11(hmon, psXY, Buffers.SIZEOF_FLOAT * psXY_offset, false);
  }

} // end of class GDI
