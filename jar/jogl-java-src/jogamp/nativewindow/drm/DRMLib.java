/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Fri Aug 18 14:57:02 CEST 2023 ----! */
/* !---- Java-Unit: [pkg jogamp.nativewindow.drm, cls DRMLib], ../build/nativewindow/gensrc/classes/jogamp/nativewindow/drm/DRMLib.java ----! */

package jogamp.nativewindow.drm;

import java.nio.*;
import java.util.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;
import com.jogamp.common.util.*;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class DRMLib {

  /** Defined as part of enum type "gbm_bo_flags" with expression '<code> ( 1 << 0 )</code>', CType: int */
  public static final int GBM_BO_USE_SCANOUT = ( 0x1 << 0x0 );
  /** Defined as part of enum type "gbm_bo_flags" with expression '<code> ( 1 << 1 )</code>', CType: int */
  public static final int GBM_BO_USE_CURSOR = ( 0x1 << 0x1 );
  /** Defined as part of enum type "gbm_bo_flags" with expression '<code> ( 1 << 2 )</code>', CType: int */
  public static final int GBM_BO_USE_RENDERING = ( 0x1 << 0x2 );
  /** Defined as part of enum type "gbm_bo_flags" with expression '<code> ( 1 << 3 )</code>', CType: int */
  public static final int GBM_BO_USE_WRITE = ( 0x1 << 0x3 );
  /** Defined as part of enum type "gbm_bo_flags" with expression '<code> ( 1 << 4 )</code>', CType: int */
  public static final int GBM_BO_USE_LINEAR = ( 0x1 << 0x4 );
  /** Defined as part of enum type "drmModeConnection" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_CONNECTED = 0x1;
  /** Defined as part of enum type "drmModeConnection" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_DISCONNECTED = 0x2;
  /** Defined as part of enum type "drmModeConnection" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_UNKNOWNCONNECTION = 0x3;
  /** Defined as part of enum type "gbm_bo_transfer_flags" with expression '<code> ( 1 << 0 )</code>', CType: int */
  public static final int GBM_BO_TRANSFER_READ = ( 0x1 << 0x0 );
  /** Defined as part of enum type "gbm_bo_transfer_flags" with expression '<code> ( 1 << 1 )</code>', CType: int */
  public static final int GBM_BO_TRANSFER_WRITE = ( 0x1 << 0x1 );
  /** Defined as part of enum type "gbm_bo_transfer_flags" with expression '<code> ( GBM_BO_TRANSFER_READ | GBM_BO_TRANSFER_WRITE )</code>', CType: int */
  public static final int GBM_BO_TRANSFER_READ_WRITE = ( GBM_BO_TRANSFER_READ | GBM_BO_TRANSFER_WRITE );
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_UNKNOWN = 0x1;
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_HORIZONTAL_RGB = 0x2;
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_HORIZONTAL_BGR = 0x3;
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>4</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_VERTICAL_RGB = 0x4;
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>5</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_VERTICAL_BGR = 0x5;
  /** Defined as part of enum type "drmModeSubPixel" with expression '<code>6</code>', CType: int */
  public static final int DRM_MODE_SUBPIXEL_NONE = 0x6;
  /** Define "GBM_BO_IMPORT_EGL_IMAGE" with expression '<code>0x5502</code>', CType: int */
  public static final int GBM_BO_IMPORT_EGL_IMAGE = 0x5502;
  /** Define "DRM_MODE_FLAG_INTERLACE" with expression '<code>(1<<4)</code>', CType: int */
  public static final int DRM_MODE_FLAG_INTERLACE = ( 0x1 << 0x4 );
  /** Define "DRM_MODE_PROP_BLOB" with expression '<code>(1<<4)</code>', CType: int */
  public static final int DRM_MODE_PROP_BLOB = ( 0x1 << 0x4 );
  /** Define "DRM_MODE_CONNECTOR_DVII" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DVII = 0x2;
  /** Define "DRM_MODE_DPMS_STANDBY" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_DPMS_STANDBY = 0x1;
  /** Define "DRM_MODE_TYPE_DRIVER" with expression '<code>(1<<6)</code>', CType: int */
  public static final int DRM_MODE_TYPE_DRIVER = ( 0x1 << 0x6 );
  /** Define "DRM_MODE_FLAG_3D_MASK" with expression '<code>(0x1f<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_MASK = ( 0x1f << 0xe );
  /** Define "DRM_MODE_FLAG_CLKDIV2" with expression '<code>(1<<13)</code>', CType: int */
  public static final int DRM_MODE_FLAG_CLKDIV2 = ( 0x1 << 0xd );
  /** Define "DRM_MODE_FLAG_3D_TOP_AND_BOTTOM" with expression '<code>(7<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_TOP_AND_BOTTOM = ( 0x7 << 0xe );
  /** Define "DRM_DISPLAY_INFO_LEN" with expression '<code>32</code>', CType: int */
  public static final int DRM_DISPLAY_INFO_LEN = 0x20;
  /** Define "DRM_MODE_SUBCONNECTOR_Composite" with expression '<code>5</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_Composite = 0x5;
  /** Define "DRM_MODE_CONNECTOR_DisplayPort" with expression '<code>10</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DisplayPort = 0xa;
  /** Define "DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL" with expression '<code>(4<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL = ( 0x4 << 0xe );
  /** Define "GBM_FORMAT_BIG_ENDIAN" with expression '<code>(1<<31)</code>', CType: int */
  public static final int GBM_FORMAT_BIG_ENDIAN = ( 0x1 << 0x1f );
  /** Define "DRM_MODE_TYPE_PREFERRED" with expression '<code>(1<<3)</code>', CType: int */
  public static final int DRM_MODE_TYPE_PREFERRED = ( 0x1 << 0x3 );
  /** Define "DRM_MODE_SCALE_NON_GPU" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_SCALE_NON_GPU = 0x0;
  /** Define "DRM_MODE_DPMS_OFF" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_DPMS_OFF = 0x3;
  /** Define "DRM_MODE_CONNECTOR_DVIA" with expression '<code>4</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DVIA = 0x4;
  /** Define "DRM_MODE_CONNECTOR_DPI" with expression '<code>17</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DPI = 0x11;
  /** Define "DRM_PLANE_TYPE_OVERLAY" with expression '<code>0</code>', CType: int */
  public static final int DRM_PLANE_TYPE_OVERLAY = 0x0;
  /** Define "DRM_MODE_CONNECTOR_DVID" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DVID = 0x3;
  /** Define "DRM_MODE_FLAG_BCAST" with expression '<code>(1<<10)</code>', CType: int */
  public static final int DRM_MODE_FLAG_BCAST = ( 0x1 << 0xa );
  /** Define "DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH" with expression '<code>(6<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH = ( 0x6 << 0xe );
  /** Define "DRM_DISPLAY_MODE_LEN" with expression '<code>32</code>', CType: int */
  public static final int DRM_DISPLAY_MODE_LEN = 0x20;
  /** Define "DRM_MODE_TYPE_DEFAULT" with expression '<code>(1<<4)</code>', CType: int */
  public static final int DRM_MODE_TYPE_DEFAULT = ( 0x1 << 0x4 );
  /** Define "DRM_MODE_ENCODER_TMDS" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_ENCODER_TMDS = 0x2;
  /** Define "DRM_MODE_CONNECTOR_SVIDEO" with expression '<code>6</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_SVIDEO = 0x6;
  /** Define "DRM_MODE_ENCODER_NONE" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_ENCODER_NONE = 0x0;
  /** Define "DRM_MODE_SUBCONNECTOR_SVIDEO" with expression '<code>6</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_SVIDEO = 0x6;
  /** Define "DRM_PLANE_TYPE_PRIMARY" with expression '<code>1</code>', CType: int */
  public static final int DRM_PLANE_TYPE_PRIMARY = 0x1;
  /** Define "DRM_CONNECTOR_NAME_LEN" with expression '<code>32</code>', CType: int */
  public static final int DRM_CONNECTOR_NAME_LEN = 0x20;
  /** Define "DRM_MODE_CONNECTOR_Composite" with expression '<code>5</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_Composite = 0x5;
  /** Define "DRM_MODE_FEATURE_KMS" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_FEATURE_KMS = 0x1;
  /** Define "DRM_MODE_FLAG_PCSYNC" with expression '<code>(1<<7)</code>', CType: int */
  public static final int DRM_MODE_FLAG_PCSYNC = ( 0x1 << 0x7 );
  /** Define "DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE" with expression '<code>(2<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE = ( 0x2 << 0xe );
  /** Define "DRM_MODE_TYPE_CLOCK_C" with expression '<code>((1<<1) | (1<<0))</code>', CType: int */
  public static final int DRM_MODE_TYPE_CLOCK_C = ( ( 0x1 << 0x1 ) | ( 0x1 << 0x0 ) );
  /** Define "DRM_MODE_FLAG_3D_NONE" with expression '<code>(0<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_NONE = ( 0x0 << 0xe );
  /** Define "GBM_BO_IMPORT_WL_BUFFER" with expression '<code>0x5501</code>', CType: int */
  public static final int GBM_BO_IMPORT_WL_BUFFER = 0x5501;
  /** Define "DRM_MODE_TYPE_CRTC_C" with expression '<code>((1<<2) | (1<<0))</code>', CType: int */
  public static final int DRM_MODE_TYPE_CRTC_C = ( ( 0x1 << 0x2 ) | ( 0x1 << 0x0 ) );
  /** Define "GBM_BO_IMPORT_FD_MODIFIER" with expression '<code>0x5504</code>', CType: int */
  public static final int GBM_BO_IMPORT_FD_MODIFIER = 0x5504;
  /** Define "DRM_MODE_CONNECTOR_9PinDIN" with expression '<code>9</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_9PinDIN = 0x9;
  /** Define "DRM_MODE_ENCODER_VIRTUAL" with expression '<code>5</code>', CType: int */
  public static final int DRM_MODE_ENCODER_VIRTUAL = 0x5;
  /** Define "DRM_MODE_FLAG_NVSYNC" with expression '<code>(1<<3)</code>', CType: int */
  public static final int DRM_MODE_FLAG_NVSYNC = ( 0x1 << 0x3 );
  /** Define "DRM_PROP_NAME_LEN" with expression '<code>32</code>', CType: int */
  public static final int DRM_PROP_NAME_LEN = 0x20;
  /** Define "DRM_MODE_CURSOR_MOVE" with expression '<code>(1<<1)</code>', CType: int */
  public static final int DRM_MODE_CURSOR_MOVE = ( 0x1 << 0x1 );
  /** Define "DRM_MODE_SUBCONNECTOR_Automatic" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_Automatic = 0x0;
  /** Define "DRM_MODE_CONNECTOR_TV" with expression '<code>13</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_TV = 0xd;
  /** Define "DRM_MODE_SUBCONNECTOR_Component" with expression '<code>8</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_Component = 0x8;
  /** Define "DRM_MODE_FLAG_3D_FRAME_PACKING" with expression '<code>(1<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_FRAME_PACKING = ( 0x1 << 0xe );
  /** Define "DRM_MODE_CONNECTOR_Unknown" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_Unknown = 0x0;
  /** Define "DRM_MODE_SUBCONNECTOR_DVIA" with expression '<code>4</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_DVIA = 0x4;
  /** Define "DRM_MODE_SUBCONNECTOR_DVID" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_DVID = 0x3;
  /** Define "DRM_MODE_FLAG_PHSYNC" with expression '<code>(1<<0)</code>', CType: int */
  public static final int DRM_MODE_FLAG_PHSYNC = ( 0x1 << 0x0 );
  /** Define "DRM_MODE_PROP_ENUM" with expression '<code>(1<<3)</code>', CType: int */
  public static final int DRM_MODE_PROP_ENUM = ( 0x1 << 0x3 );
  /** Define "DRM_MODE_FLAG_NHSYNC" with expression '<code>(1<<1)</code>', CType: int */
  public static final int DRM_MODE_FLAG_NHSYNC = ( 0x1 << 0x1 );
  /** Define "DRM_MODE_ENCODER_TVDAC" with expression '<code>4</code>', CType: int */
  public static final int DRM_MODE_ENCODER_TVDAC = 0x4;
  /** Define "DRM_MODE_ENCODER_DPI" with expression '<code>8</code>', CType: int */
  public static final int DRM_MODE_ENCODER_DPI = 0x8;
  /** Define "DRM_MODE_SUBCONNECTOR_Unknown" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_Unknown = 0x0;
  /** Define "DRM_MODE_FLAG_PIXMUX" with expression '<code>(1<<11)</code>', CType: int */
  public static final int DRM_MODE_FLAG_PIXMUX = ( 0x1 << 0xb );
  /** Define "DRM_MODE_FLAG_DBLCLK" with expression '<code>(1<<12)</code>', CType: int */
  public static final int DRM_MODE_FLAG_DBLCLK = ( 0x1 << 0xc );
  /** Define "DRM_MODE_CONNECTOR_LVDS" with expression '<code>7</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_LVDS = 0x7;
  /** Define "DRM_MODE_DITHERING_ON" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_DITHERING_ON = 0x1;
  /** Define "DRM_MODE_TYPE_BUILTIN" with expression '<code>(1<<0)</code>', CType: int */
  public static final int DRM_MODE_TYPE_BUILTIN = ( 0x1 << 0x0 );
  /** Define "DRM_MODE_PROP_IMMUTABLE" with expression '<code>(1<<2)</code>', CType: int */
  public static final int DRM_MODE_PROP_IMMUTABLE = ( 0x1 << 0x2 );
  /** Define "DRM_MODE_FLAG_CSYNC" with expression '<code>(1<<6)</code>', CType: int */
  public static final int DRM_MODE_FLAG_CSYNC = ( 0x1 << 0x6 );
  /** Define "DRM_MODE_SCALE_ASPECT" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_SCALE_ASPECT = 0x3;
  /** Define "DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF" with expression '<code>(8<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF = ( 0x8 << 0xe );
  /** Define "DRM_PLANE_TYPE_CURSOR" with expression '<code>2</code>', CType: int */
  public static final int DRM_PLANE_TYPE_CURSOR = 0x2;
  /** Define "DRM_MODE_CONNECTOR_eDP" with expression '<code>14</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_eDP = 0xe;
  /** Define "DRM_MODE_CONNECTOR_VGA" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_VGA = 0x1;
  /** Define "DRM_MODE_CONNECTOR_Component" with expression '<code>8</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_Component = 0x8;
  /** Define "DRM_MODE_DPMS_ON" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_DPMS_ON = 0x0;
  /** Define "DRM_MODE_FLAG_HSKEW" with expression '<code>(1<<9)</code>', CType: int */
  public static final int DRM_MODE_FLAG_HSKEW = ( 0x1 << 0x9 );
  /** Define "DRM_MODE_CURSOR_BO" with expression '<code>(1<<0)</code>', CType: int */
  public static final int DRM_MODE_CURSOR_BO = ( 0x1 << 0x0 );
  /** Define "DRM_MODE_ENCODER_DSI" with expression '<code>6</code>', CType: int */
  public static final int DRM_MODE_ENCODER_DSI = 0x6;
  /** Define "DRM_MODE_FLAG_PVSYNC" with expression '<code>(1<<2)</code>', CType: int */
  public static final int DRM_MODE_FLAG_PVSYNC = ( 0x1 << 0x2 );
  /** Define "DRM_MODE_FEATURE_DIRTYFB" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_FEATURE_DIRTYFB = 0x1;
  /** Define "DRM_MODE_CONNECTOR_DSI" with expression '<code>16</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_DSI = 0x10;
  /** Define "GBM_BO_IMPORT_FD" with expression '<code>0x5503</code>', CType: int */
  public static final int GBM_BO_IMPORT_FD = 0x5503;
  /** Define "DRM_MODE_PROP_PENDING" with expression '<code>(1<<0)</code>', CType: int */
  public static final int DRM_MODE_PROP_PENDING = ( 0x1 << 0x0 );
  /** Define "DRM_MODE_SCALE_FULLSCREEN" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_SCALE_FULLSCREEN = 0x1;
  /** Define "DRM_MODE_FLAG_3D_LINE_ALTERNATIVE" with expression '<code>(3<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_LINE_ALTERNATIVE = ( 0x3 << 0xe );
  /** Define "DRM_MODE_PROP_RANGE" with expression '<code>(1<<1)</code>', CType: int */
  public static final int DRM_MODE_PROP_RANGE = ( 0x1 << 0x1 );
  /** Define "DRM_MODE_FLAG_3D_L_DEPTH" with expression '<code>(5<<14)</code>', CType: int */
  public static final int DRM_MODE_FLAG_3D_L_DEPTH = ( 0x5 << 0xe );
  /** Define "DRM_MODE_DPMS_SUSPEND" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_DPMS_SUSPEND = 0x2;
  /** Define "DRM_MODE_SUBCONNECTOR_SCART" with expression '<code>9</code>', CType: int */
  public static final int DRM_MODE_SUBCONNECTOR_SCART = 0x9;
  /** Define "DRM_MODE_CONNECTOR_HDMIB" with expression '<code>12</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_HDMIB = 0xc;
  /** Define "DRM_MODE_CONNECTOR_HDMIA" with expression '<code>11</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_HDMIA = 0xb;
  /** Define "DRM_MODE_FLAG_NCSYNC" with expression '<code>(1<<8)</code>', CType: int */
  public static final int DRM_MODE_FLAG_NCSYNC = ( 0x1 << 0x8 );
  /** Define "DRM_MODE_DITHERING_OFF" with expression '<code>0</code>', CType: int */
  public static final int DRM_MODE_DITHERING_OFF = 0x0;
  /** Define "DRM_MODE_ENCODER_LVDS" with expression '<code>3</code>', CType: int */
  public static final int DRM_MODE_ENCODER_LVDS = 0x3;
  /** Define "DRM_MODE_ENCODER_DAC" with expression '<code>1</code>', CType: int */
  public static final int DRM_MODE_ENCODER_DAC = 0x1;
  /** Define "DRM_MODE_SCALE_NO_SCALE" with expression '<code>2</code>', CType: int */
  public static final int DRM_MODE_SCALE_NO_SCALE = 0x2;
  /** Define "DRM_MODE_CONNECTOR_VIRTUAL" with expression '<code>15</code>', CType: int */
  public static final int DRM_MODE_CONNECTOR_VIRTUAL = 0xf;
  /** Define "DRM_MODE_TYPE_USERDEF" with expression '<code>(1<<5)</code>', CType: int */
  public static final int DRM_MODE_TYPE_USERDEF = ( 0x1 << 0x5 );
  /** Define "DRM_MODE_FLAG_DBLSCAN" with expression '<code>(1<<5)</code>', CType: int */
  public static final int DRM_MODE_FLAG_DBLSCAN = ( 0x1 << 0x5 );
  /** Define "DRM_MODE_ENCODER_DPMST" with expression '<code>7</code>', CType: int */
  public static final int DRM_MODE_ENCODER_DPMST = 0x7;

  /** Interface to C language function: <br> <code>int drmAvailable()</code><br>   */
  public static native int drmAvailable();

  /** Interface to C language function: <br> <code>int drmOpen(const char *  drivername, const char *  busid)</code><br>   */
  public static native int drmOpen(String drivername, String busid);

  /** Interface to C language function: <br> <code>int drmClose(int fd)</code><br>   */
  public static native int drmClose(int fd);

  /** Interface to C language function: <br> <code>void drmModeFreeModeInfo(drmModeModeInfoPtr ptr)</code><br>   */
  public static void drmModeFreeModeInfo(drmModeModeInfo ptr)  {

    drmModeFreeModeInfo1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeModeInfo(drmModeModeInfoPtr ptr)</code><br>   */
  private static native void drmModeFreeModeInfo1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>void drmModeFreeResources(drmModeResPtr ptr)</code><br>   */
  public static void drmModeFreeResources(drmModeRes ptr)  {

    drmModeFreeResources1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeResources(drmModeResPtr ptr)</code><br>   */
  private static native void drmModeFreeResources1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>void drmModeFreeFB(drmModeFBPtr ptr)</code><br>   */
  public static void drmModeFreeFB(drmModeFB ptr)  {

    drmModeFreeFB1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeFB(drmModeFBPtr ptr)</code><br>   */
  private static native void drmModeFreeFB1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>void drmModeFreeCrtc(drmModeCrtcPtr ptr)</code><br>   */
  public static void drmModeFreeCrtc(drmModeCrtc ptr)  {

    drmModeFreeCrtc1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeCrtc(drmModeCrtcPtr ptr)</code><br>   */
  private static native void drmModeFreeCrtc1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>void drmModeFreeConnector(drmModeConnectorPtr ptr)</code><br>   */
  public static void drmModeFreeConnector(drmModeConnector ptr)  {

    drmModeFreeConnector1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeConnector(drmModeConnectorPtr ptr)</code><br>   */
  private static native void drmModeFreeConnector1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>void drmModeFreeEncoder(drmModeEncoderPtr ptr)</code><br>   */
  public static void drmModeFreeEncoder(drmModeEncoder ptr)  {

    drmModeFreeEncoder1(((ptr == null) ? null : ptr.getBuffer()));
  }

  /** Entry point to C language function: <code>void drmModeFreeEncoder(drmModeEncoderPtr ptr)</code><br>   */
  private static native void drmModeFreeEncoder1(ByteBuffer ptr);

  /** Interface to C language function: <br> <code>drmModeResPtr drmModeGetResources(int fd)</code><br>   */
  public static drmModeRes drmModeGetResources(int fd)  {

    final ByteBuffer _res;
    _res = drmModeGetResources1(fd);
    if (_res == null) return null;
    return drmModeRes.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeResPtr drmModeGetResources(int fd)</code><br>   */
  private static native ByteBuffer drmModeGetResources1(int fd);

  /** Interface to C language function: <br> <code>drmModeFBPtr drmModeGetFB(int fd, uint32_t bufferId)</code><br>   */
  public static drmModeFB drmModeGetFB(int fd, int bufferId)  {

    final ByteBuffer _res;
    _res = drmModeGetFB1(fd, bufferId);
    if (_res == null) return null;
    return drmModeFB.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeFBPtr drmModeGetFB(int fd, uint32_t bufferId)</code><br>   */
  private static native ByteBuffer drmModeGetFB1(int fd, int bufferId);

  /** Interface to C language function: <br> <code>int drmModeAddFB(int fd, uint32_t width, uint32_t height, uint8_t depth, uint8_t bpp, uint32_t pitch, uint32_t bo_handle, uint32_t *  buf_id)</code><br>
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeAddFB(int fd, int width, int height, byte depth, byte bpp, int pitch, int bo_handle, IntBuffer buf_id)  {

    final boolean buf_id_is_direct = Buffers.isDirect(buf_id);
        return drmModeAddFB1(fd, width, height, depth, bpp, pitch, bo_handle, buf_id_is_direct ? buf_id : Buffers.getArray(buf_id), buf_id_is_direct ? Buffers.getDirectBufferByteOffset(buf_id) : Buffers.getIndirectBufferByteOffset(buf_id), buf_id_is_direct);
  }

  /** Entry point to C language function: <code>int drmModeAddFB(int fd, uint32_t width, uint32_t height, uint8_t depth, uint8_t bpp, uint32_t pitch, uint32_t bo_handle, uint32_t *  buf_id)</code><br>
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeAddFB1(int fd, int width, int height, byte depth, byte bpp, int pitch, int bo_handle, Object buf_id, int buf_id_byte_offset, boolean buf_id_is_direct);

  /** Interface to C language function: <br> <code>int drmModeAddFB(int fd, uint32_t width, uint32_t height, uint8_t depth, uint8_t bpp, uint32_t pitch, uint32_t bo_handle, uint32_t *  buf_id)</code><br>   */
  public static int drmModeAddFB(int fd, int width, int height, byte depth, byte bpp, int pitch, int bo_handle, int[] buf_id, int buf_id_offset)  {

    if(buf_id != null && buf_id.length <= buf_id_offset)
      throw new RuntimeException("array offset argument \"buf_id_offset\" (" + buf_id_offset + ") equals or exceeds array length (" + buf_id.length + ")");
        return drmModeAddFB1(fd, width, height, depth, bpp, pitch, bo_handle, buf_id, Buffers.SIZEOF_INT * buf_id_offset, false);
  }

  /** Interface to C language function: <br> <code>int drmModeAddFB2(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], uint32_t *  buf_id, uint32_t flags)</code><br>
      @param bo_handles a direct or array-backed {@link java.nio.IntBuffer}
      @param pitches a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link java.nio.IntBuffer}
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeAddFB2(int fd, int width, int height, int pixel_format, IntBuffer bo_handles, IntBuffer pitches, IntBuffer offsets, IntBuffer buf_id, int flags)  {

    if ( Buffers.remainingElem(bo_handles) < 4)
      throw new RuntimeException("Array \"bo_handles\" length (" + Buffers.remainingElem(bo_handles)+ ") was less than the required (4)");
    final boolean bo_handles_is_direct = Buffers.isDirect(bo_handles);
    if ( Buffers.remainingElem(pitches) < 4)
      throw new RuntimeException("Array \"pitches\" length (" + Buffers.remainingElem(pitches)+ ") was less than the required (4)");
    final boolean pitches_is_direct = Buffers.isDirect(pitches);
    if ( Buffers.remainingElem(offsets) < 4)
      throw new RuntimeException("Array \"offsets\" length (" + Buffers.remainingElem(offsets)+ ") was less than the required (4)");
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    final boolean buf_id_is_direct = Buffers.isDirect(buf_id);
        return drmModeAddFB21(fd, width, height, pixel_format, bo_handles_is_direct ? bo_handles : Buffers.getArray(bo_handles), bo_handles_is_direct ? Buffers.getDirectBufferByteOffset(bo_handles) : Buffers.getIndirectBufferByteOffset(bo_handles), bo_handles_is_direct, pitches_is_direct ? pitches : Buffers.getArray(pitches), pitches_is_direct ? Buffers.getDirectBufferByteOffset(pitches) : Buffers.getIndirectBufferByteOffset(pitches), pitches_is_direct, offsets_is_direct ? offsets : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, buf_id_is_direct ? buf_id : Buffers.getArray(buf_id), buf_id_is_direct ? Buffers.getDirectBufferByteOffset(buf_id) : Buffers.getIndirectBufferByteOffset(buf_id), buf_id_is_direct, flags);
  }

  /** Entry point to C language function: <code>int drmModeAddFB2(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], uint32_t *  buf_id, uint32_t flags)</code><br>
      @param bo_handles a direct or array-backed {@link java.nio.IntBuffer}
      @param pitches a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link java.nio.IntBuffer}
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeAddFB21(int fd, int width, int height, int pixel_format, Object bo_handles, int bo_handles_byte_offset, boolean bo_handles_is_direct, Object pitches, int pitches_byte_offset, boolean pitches_is_direct, Object offsets, int offsets_byte_offset, boolean offsets_is_direct, Object buf_id, int buf_id_byte_offset, boolean buf_id_is_direct, int flags);

  /** Interface to C language function: <br> <code>int drmModeAddFB2(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], uint32_t *  buf_id, uint32_t flags)</code><br>   */
  public static int drmModeAddFB2(int fd, int width, int height, int pixel_format, int[] bo_handles, int bo_handles_offset, int[] pitches, int pitches_offset, int[] offsets, int offsets_offset, int[] buf_id, int buf_id_offset, int flags)  {

    if ( bo_handles.length < 4)
      throw new RuntimeException("Array \"bo_handles\" length (" + bo_handles.length+ ") was less than the required (4)");
    if(bo_handles != null && bo_handles.length <= bo_handles_offset)
      throw new RuntimeException("array offset argument \"bo_handles_offset\" (" + bo_handles_offset + ") equals or exceeds array length (" + bo_handles.length + ")");
    if ( pitches.length < 4)
      throw new RuntimeException("Array \"pitches\" length (" + pitches.length+ ") was less than the required (4)");
    if(pitches != null && pitches.length <= pitches_offset)
      throw new RuntimeException("array offset argument \"pitches_offset\" (" + pitches_offset + ") equals or exceeds array length (" + pitches.length + ")");
    if ( offsets.length < 4)
      throw new RuntimeException("Array \"offsets\" length (" + offsets.length+ ") was less than the required (4)");
    if(offsets != null && offsets.length <= offsets_offset)
      throw new RuntimeException("array offset argument \"offsets_offset\" (" + offsets_offset + ") equals or exceeds array length (" + offsets.length + ")");
    if(buf_id != null && buf_id.length <= buf_id_offset)
      throw new RuntimeException("array offset argument \"buf_id_offset\" (" + buf_id_offset + ") equals or exceeds array length (" + buf_id.length + ")");
        return drmModeAddFB21(fd, width, height, pixel_format, bo_handles, Buffers.SIZEOF_INT * bo_handles_offset, false, pitches, Buffers.SIZEOF_INT * pitches_offset, false, offsets, Buffers.SIZEOF_INT * offsets_offset, false, buf_id, Buffers.SIZEOF_INT * buf_id_offset, false, flags);
  }

  /** Interface to C language function: <br> <code>int drmModeAddFB2WithModifiers(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], const uint64_t modifier[4], uint32_t *  buf_id, uint32_t flags)</code><br>
      @param bo_handles a direct or array-backed {@link java.nio.IntBuffer}
      @param pitches a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link java.nio.IntBuffer}
      @param modifier a direct or array-backed {@link java.nio.LongBuffer}
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeAddFB2WithModifiers(int fd, int width, int height, int pixel_format, IntBuffer bo_handles, IntBuffer pitches, IntBuffer offsets, LongBuffer modifier, IntBuffer buf_id, int flags)  {

    if ( Buffers.remainingElem(bo_handles) < 4)
      throw new RuntimeException("Array \"bo_handles\" length (" + Buffers.remainingElem(bo_handles)+ ") was less than the required (4)");
    final boolean bo_handles_is_direct = Buffers.isDirect(bo_handles);
    if ( Buffers.remainingElem(pitches) < 4)
      throw new RuntimeException("Array \"pitches\" length (" + Buffers.remainingElem(pitches)+ ") was less than the required (4)");
    final boolean pitches_is_direct = Buffers.isDirect(pitches);
    if ( Buffers.remainingElem(offsets) < 4)
      throw new RuntimeException("Array \"offsets\" length (" + Buffers.remainingElem(offsets)+ ") was less than the required (4)");
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    if ( Buffers.remainingElem(modifier) < 4)
      throw new RuntimeException("Array \"modifier\" length (" + Buffers.remainingElem(modifier)+ ") was less than the required (4)");
    final boolean modifier_is_direct = Buffers.isDirect(modifier);
    final boolean buf_id_is_direct = Buffers.isDirect(buf_id);
        return drmModeAddFB2WithModifiers1(fd, width, height, pixel_format, bo_handles_is_direct ? bo_handles : Buffers.getArray(bo_handles), bo_handles_is_direct ? Buffers.getDirectBufferByteOffset(bo_handles) : Buffers.getIndirectBufferByteOffset(bo_handles), bo_handles_is_direct, pitches_is_direct ? pitches : Buffers.getArray(pitches), pitches_is_direct ? Buffers.getDirectBufferByteOffset(pitches) : Buffers.getIndirectBufferByteOffset(pitches), pitches_is_direct, offsets_is_direct ? offsets : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, modifier_is_direct ? modifier : Buffers.getArray(modifier), modifier_is_direct ? Buffers.getDirectBufferByteOffset(modifier) : Buffers.getIndirectBufferByteOffset(modifier), modifier_is_direct, buf_id_is_direct ? buf_id : Buffers.getArray(buf_id), buf_id_is_direct ? Buffers.getDirectBufferByteOffset(buf_id) : Buffers.getIndirectBufferByteOffset(buf_id), buf_id_is_direct, flags);
  }

  /** Entry point to C language function: <code>int drmModeAddFB2WithModifiers(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], const uint64_t modifier[4], uint32_t *  buf_id, uint32_t flags)</code><br>
      @param bo_handles a direct or array-backed {@link java.nio.IntBuffer}
      @param pitches a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link java.nio.IntBuffer}
      @param modifier a direct or array-backed {@link java.nio.LongBuffer}
      @param buf_id a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeAddFB2WithModifiers1(int fd, int width, int height, int pixel_format, Object bo_handles, int bo_handles_byte_offset, boolean bo_handles_is_direct, Object pitches, int pitches_byte_offset, boolean pitches_is_direct, Object offsets, int offsets_byte_offset, boolean offsets_is_direct, Object modifier, int modifier_byte_offset, boolean modifier_is_direct, Object buf_id, int buf_id_byte_offset, boolean buf_id_is_direct, int flags);

  /** Interface to C language function: <br> <code>int drmModeAddFB2WithModifiers(int fd, uint32_t width, uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4], const uint32_t pitches[4], const uint32_t offsets[4], const uint64_t modifier[4], uint32_t *  buf_id, uint32_t flags)</code><br>   */
  public static int drmModeAddFB2WithModifiers(int fd, int width, int height, int pixel_format, int[] bo_handles, int bo_handles_offset, int[] pitches, int pitches_offset, int[] offsets, int offsets_offset, long[] modifier, int modifier_offset, int[] buf_id, int buf_id_offset, int flags)  {

    if ( bo_handles.length < 4)
      throw new RuntimeException("Array \"bo_handles\" length (" + bo_handles.length+ ") was less than the required (4)");
    if(bo_handles != null && bo_handles.length <= bo_handles_offset)
      throw new RuntimeException("array offset argument \"bo_handles_offset\" (" + bo_handles_offset + ") equals or exceeds array length (" + bo_handles.length + ")");
    if ( pitches.length < 4)
      throw new RuntimeException("Array \"pitches\" length (" + pitches.length+ ") was less than the required (4)");
    if(pitches != null && pitches.length <= pitches_offset)
      throw new RuntimeException("array offset argument \"pitches_offset\" (" + pitches_offset + ") equals or exceeds array length (" + pitches.length + ")");
    if ( offsets.length < 4)
      throw new RuntimeException("Array \"offsets\" length (" + offsets.length+ ") was less than the required (4)");
    if(offsets != null && offsets.length <= offsets_offset)
      throw new RuntimeException("array offset argument \"offsets_offset\" (" + offsets_offset + ") equals or exceeds array length (" + offsets.length + ")");
    if ( modifier.length < 4)
      throw new RuntimeException("Array \"modifier\" length (" + modifier.length+ ") was less than the required (4)");
    if(modifier != null && modifier.length <= modifier_offset)
      throw new RuntimeException("array offset argument \"modifier_offset\" (" + modifier_offset + ") equals or exceeds array length (" + modifier.length + ")");
    if(buf_id != null && buf_id.length <= buf_id_offset)
      throw new RuntimeException("array offset argument \"buf_id_offset\" (" + buf_id_offset + ") equals or exceeds array length (" + buf_id.length + ")");
        return drmModeAddFB2WithModifiers1(fd, width, height, pixel_format, bo_handles, Buffers.SIZEOF_INT * bo_handles_offset, false, pitches, Buffers.SIZEOF_INT * pitches_offset, false, offsets, Buffers.SIZEOF_INT * offsets_offset, false, modifier, Buffers.SIZEOF_LONG * modifier_offset, false, buf_id, Buffers.SIZEOF_INT * buf_id_offset, false, flags);
  }

  /** Interface to C language function: <br> <code>int drmModeRmFB(int fd, uint32_t bufferId)</code><br>   */
  public static native int drmModeRmFB(int fd, int bufferId);

  /** Interface to C language function: <br> <code>drmModeCrtcPtr drmModeGetCrtc(int fd, uint32_t crtcId)</code><br>   */
  public static drmModeCrtc drmModeGetCrtc(int fd, int crtcId)  {

    final ByteBuffer _res;
    _res = drmModeGetCrtc1(fd, crtcId);
    if (_res == null) return null;
    return drmModeCrtc.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeCrtcPtr drmModeGetCrtc(int fd, uint32_t crtcId)</code><br>   */
  private static native ByteBuffer drmModeGetCrtc1(int fd, int crtcId);

  /** Interface to C language function: <br> <code>int drmModeSetCrtc(int fd, uint32_t crtcId, uint32_t bufferId, uint32_t x, uint32_t y, uint32_t *  connectors, int count, drmModeModeInfoPtr mode)</code><br>
      @param connectors a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeSetCrtc(int fd, int crtcId, int bufferId, int x, int y, IntBuffer connectors, int count, drmModeModeInfo mode)  {

    final boolean connectors_is_direct = Buffers.isDirect(connectors);
        return drmModeSetCrtc1(fd, crtcId, bufferId, x, y, connectors_is_direct ? connectors : Buffers.getArray(connectors), connectors_is_direct ? Buffers.getDirectBufferByteOffset(connectors) : Buffers.getIndirectBufferByteOffset(connectors), connectors_is_direct, count, ((mode == null) ? null : mode.getBuffer()));
  }

  /** Entry point to C language function: <code>int drmModeSetCrtc(int fd, uint32_t crtcId, uint32_t bufferId, uint32_t x, uint32_t y, uint32_t *  connectors, int count, drmModeModeInfoPtr mode)</code><br>
      @param connectors a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeSetCrtc1(int fd, int crtcId, int bufferId, int x, int y, Object connectors, int connectors_byte_offset, boolean connectors_is_direct, int count, ByteBuffer mode);

  /** Interface to C language function: <br> <code>int drmModeSetCrtc(int fd, uint32_t crtcId, uint32_t bufferId, uint32_t x, uint32_t y, uint32_t *  connectors, int count, drmModeModeInfoPtr mode)</code><br>   */
  public static int drmModeSetCrtc(int fd, int crtcId, int bufferId, int x, int y, int[] connectors, int connectors_offset, int count, drmModeModeInfo mode)  {

    if(connectors != null && connectors.length <= connectors_offset)
      throw new RuntimeException("array offset argument \"connectors_offset\" (" + connectors_offset + ") equals or exceeds array length (" + connectors.length + ")");
        return drmModeSetCrtc1(fd, crtcId, bufferId, x, y, connectors, Buffers.SIZEOF_INT * connectors_offset, false, count, ((mode == null) ? null : mode.getBuffer()));
  }

  /** Interface to C language function: <br> <code>int drmModeSetCursor(int fd, uint32_t crtcId, uint32_t bo_handle, uint32_t width, uint32_t height)</code><br>   */
  public static native int drmModeSetCursor(int fd, int crtcId, int bo_handle, int width, int height);

  /** Interface to C language function: <br> <code>int drmModeSetCursor2(int fd, uint32_t crtcId, uint32_t bo_handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y)</code><br>   */
  public static native int drmModeSetCursor2(int fd, int crtcId, int bo_handle, int width, int height, int hot_x, int hot_y);

  /** Interface to C language function: <br> <code>int drmModeMoveCursor(int fd, uint32_t crtcId, int x, int y)</code><br>   */
  public static native int drmModeMoveCursor(int fd, int crtcId, int x, int y);

  /** Interface to C language function: <br> <code>drmModeEncoderPtr drmModeGetEncoder(int fd, uint32_t encoder_id)</code><br>   */
  public static drmModeEncoder drmModeGetEncoder(int fd, int encoder_id)  {

    final ByteBuffer _res;
    _res = drmModeGetEncoder1(fd, encoder_id);
    if (_res == null) return null;
    return drmModeEncoder.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeEncoderPtr drmModeGetEncoder(int fd, uint32_t encoder_id)</code><br>   */
  private static native ByteBuffer drmModeGetEncoder1(int fd, int encoder_id);

  /** Interface to C language function: <br> <code>drmModeConnectorPtr drmModeGetConnector(int fd, uint32_t connectorId)</code><br>   */
  public static drmModeConnector drmModeGetConnector(int fd, int connectorId)  {

    final ByteBuffer _res;
    _res = drmModeGetConnector1(fd, connectorId);
    if (_res == null) return null;
    return drmModeConnector.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeConnectorPtr drmModeGetConnector(int fd, uint32_t connectorId)</code><br>   */
  private static native ByteBuffer drmModeGetConnector1(int fd, int connectorId);

  /** Interface to C language function: <br> <code>drmModeConnectorPtr drmModeGetConnectorCurrent(int fd, uint32_t connector_id)</code><br>   */
  public static drmModeConnector drmModeGetConnectorCurrent(int fd, int connector_id)  {

    final ByteBuffer _res;
    _res = drmModeGetConnectorCurrent1(fd, connector_id);
    if (_res == null) return null;
    return drmModeConnector.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>drmModeConnectorPtr drmModeGetConnectorCurrent(int fd, uint32_t connector_id)</code><br>   */
  private static native ByteBuffer drmModeGetConnectorCurrent1(int fd, int connector_id);

  /** Interface to C language function: <br> <code>int drmModeAttachMode(int fd, uint32_t connectorId, drmModeModeInfoPtr mode_info)</code><br>   */
  public static int drmModeAttachMode(int fd, int connectorId, drmModeModeInfo mode_info)  {

        return drmModeAttachMode1(fd, connectorId, ((mode_info == null) ? null : mode_info.getBuffer()));
  }

  /** Entry point to C language function: <code>int drmModeAttachMode(int fd, uint32_t connectorId, drmModeModeInfoPtr mode_info)</code><br>   */
  private static native int drmModeAttachMode1(int fd, int connectorId, ByteBuffer mode_info);

  /** Interface to C language function: <br> <code>int drmModeDetachMode(int fd, uint32_t connectorId, drmModeModeInfoPtr mode_info)</code><br>   */
  public static int drmModeDetachMode(int fd, int connectorId, drmModeModeInfo mode_info)  {

        return drmModeDetachMode1(fd, connectorId, ((mode_info == null) ? null : mode_info.getBuffer()));
  }

  /** Entry point to C language function: <code>int drmModeDetachMode(int fd, uint32_t connectorId, drmModeModeInfoPtr mode_info)</code><br>   */
  private static native int drmModeDetachMode1(int fd, int connectorId, ByteBuffer mode_info);

  /** Interface to C language function: <br> <code>int drmModeConnectorSetProperty(int fd, uint32_t connector_id, uint32_t property_id, uint64_t value)</code><br>   */
  public static native int drmModeConnectorSetProperty(int fd, int connector_id, int property_id, long value);

  /** Interface to C language function: <br> <code>int drmCheckModesettingSupported(const char *  busid)</code><br>   */
  public static native int drmCheckModesettingSupported(String busid);

  /** Interface to C language function: <br> <code>int drmModeCrtcSetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>
      @param red a direct or array-backed {@link java.nio.ShortBuffer}
      @param green a direct or array-backed {@link java.nio.ShortBuffer}
      @param blue a direct or array-backed {@link java.nio.ShortBuffer}   */
  public static int drmModeCrtcSetGamma(int fd, int crtc_id, int size, ShortBuffer red, ShortBuffer green, ShortBuffer blue)  {

    final boolean red_is_direct = Buffers.isDirect(red);
    final boolean green_is_direct = Buffers.isDirect(green);
    final boolean blue_is_direct = Buffers.isDirect(blue);
        return drmModeCrtcSetGamma1(fd, crtc_id, size, red_is_direct ? red : Buffers.getArray(red), red_is_direct ? Buffers.getDirectBufferByteOffset(red) : Buffers.getIndirectBufferByteOffset(red), red_is_direct, green_is_direct ? green : Buffers.getArray(green), green_is_direct ? Buffers.getDirectBufferByteOffset(green) : Buffers.getIndirectBufferByteOffset(green), green_is_direct, blue_is_direct ? blue : Buffers.getArray(blue), blue_is_direct ? Buffers.getDirectBufferByteOffset(blue) : Buffers.getIndirectBufferByteOffset(blue), blue_is_direct);
  }

  /** Entry point to C language function: <code>int drmModeCrtcSetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>
      @param red a direct or array-backed {@link java.nio.ShortBuffer}
      @param green a direct or array-backed {@link java.nio.ShortBuffer}
      @param blue a direct or array-backed {@link java.nio.ShortBuffer}   */
  private static native int drmModeCrtcSetGamma1(int fd, int crtc_id, int size, Object red, int red_byte_offset, boolean red_is_direct, Object green, int green_byte_offset, boolean green_is_direct, Object blue, int blue_byte_offset, boolean blue_is_direct);

  /** Interface to C language function: <br> <code>int drmModeCrtcSetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>   */
  public static int drmModeCrtcSetGamma(int fd, int crtc_id, int size, short[] red, int red_offset, short[] green, int green_offset, short[] blue, int blue_offset)  {

    if(red != null && red.length <= red_offset)
      throw new RuntimeException("array offset argument \"red_offset\" (" + red_offset + ") equals or exceeds array length (" + red.length + ")");
    if(green != null && green.length <= green_offset)
      throw new RuntimeException("array offset argument \"green_offset\" (" + green_offset + ") equals or exceeds array length (" + green.length + ")");
    if(blue != null && blue.length <= blue_offset)
      throw new RuntimeException("array offset argument \"blue_offset\" (" + blue_offset + ") equals or exceeds array length (" + blue.length + ")");
        return drmModeCrtcSetGamma1(fd, crtc_id, size, red, Buffers.SIZEOF_SHORT * red_offset, false, green, Buffers.SIZEOF_SHORT * green_offset, false, blue, Buffers.SIZEOF_SHORT * blue_offset, false);
  }

  /** Interface to C language function: <br> <code>int drmModeCrtcGetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>
      @param red a direct or array-backed {@link java.nio.ShortBuffer}
      @param green a direct or array-backed {@link java.nio.ShortBuffer}
      @param blue a direct or array-backed {@link java.nio.ShortBuffer}   */
  public static int drmModeCrtcGetGamma(int fd, int crtc_id, int size, ShortBuffer red, ShortBuffer green, ShortBuffer blue)  {

    final boolean red_is_direct = Buffers.isDirect(red);
    final boolean green_is_direct = Buffers.isDirect(green);
    final boolean blue_is_direct = Buffers.isDirect(blue);
        return drmModeCrtcGetGamma1(fd, crtc_id, size, red_is_direct ? red : Buffers.getArray(red), red_is_direct ? Buffers.getDirectBufferByteOffset(red) : Buffers.getIndirectBufferByteOffset(red), red_is_direct, green_is_direct ? green : Buffers.getArray(green), green_is_direct ? Buffers.getDirectBufferByteOffset(green) : Buffers.getIndirectBufferByteOffset(green), green_is_direct, blue_is_direct ? blue : Buffers.getArray(blue), blue_is_direct ? Buffers.getDirectBufferByteOffset(blue) : Buffers.getIndirectBufferByteOffset(blue), blue_is_direct);
  }

  /** Entry point to C language function: <code>int drmModeCrtcGetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>
      @param red a direct or array-backed {@link java.nio.ShortBuffer}
      @param green a direct or array-backed {@link java.nio.ShortBuffer}
      @param blue a direct or array-backed {@link java.nio.ShortBuffer}   */
  private static native int drmModeCrtcGetGamma1(int fd, int crtc_id, int size, Object red, int red_byte_offset, boolean red_is_direct, Object green, int green_byte_offset, boolean green_is_direct, Object blue, int blue_byte_offset, boolean blue_is_direct);

  /** Interface to C language function: <br> <code>int drmModeCrtcGetGamma(int fd, uint32_t crtc_id, uint32_t size, uint16_t *  red, uint16_t *  green, uint16_t *  blue)</code><br>   */
  public static int drmModeCrtcGetGamma(int fd, int crtc_id, int size, short[] red, int red_offset, short[] green, int green_offset, short[] blue, int blue_offset)  {

    if(red != null && red.length <= red_offset)
      throw new RuntimeException("array offset argument \"red_offset\" (" + red_offset + ") equals or exceeds array length (" + red.length + ")");
    if(green != null && green.length <= green_offset)
      throw new RuntimeException("array offset argument \"green_offset\" (" + green_offset + ") equals or exceeds array length (" + green.length + ")");
    if(blue != null && blue.length <= blue_offset)
      throw new RuntimeException("array offset argument \"blue_offset\" (" + blue_offset + ") equals or exceeds array length (" + blue.length + ")");
        return drmModeCrtcGetGamma1(fd, crtc_id, size, red, Buffers.SIZEOF_SHORT * red_offset, false, green, Buffers.SIZEOF_SHORT * green_offset, false, blue, Buffers.SIZEOF_SHORT * blue_offset, false);
  }

  /** Interface to C language function: <br> <code>int drmModePageFlip(int fd, uint32_t crtc_id, uint32_t fb_id, uint32_t flags, void *  user_data)</code><br>   */
  public static native int drmModePageFlip(int fd, int crtc_id, int fb_id, int flags, long user_data);

  /** Interface to C language function: <br> <code>int drmModePageFlipTarget(int fd, uint32_t crtc_id, uint32_t fb_id, uint32_t flags, void *  user_data, uint32_t target_vblank)</code><br>   */
  public static native int drmModePageFlipTarget(int fd, int crtc_id, int fb_id, int flags, long user_data, int target_vblank);

  /** Interface to C language function: <br> <code>int drmModeSetPlane(int fd, uint32_t plane_id, uint32_t crtc_id, uint32_t fb_id, uint32_t flags, int32_t crtc_x, int32_t crtc_y, uint32_t crtc_w, uint32_t crtc_h, uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h)</code><br>   */
  public static native int drmModeSetPlane(int fd, int plane_id, int crtc_id, int fb_id, int flags, int crtc_x, int crtc_y, int crtc_w, int crtc_h, int src_x, int src_y, int src_w, int src_h);

  /** Interface to C language function: <br> <code>int drmModeObjectSetProperty(int fd, uint32_t object_id, uint32_t object_type, uint32_t property_id, uint64_t value)</code><br>   */
  public static native int drmModeObjectSetProperty(int fd, int object_id, int object_type, int property_id, long value);

  /** Interface to C language function: <br> <code>int drmModeCreatePropertyBlob(int fd, const void *  data, size_t size, uint32_t *  id)</code><br>
      @param id a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeCreatePropertyBlob(int fd, long data, long size, IntBuffer id)  {

    final boolean id_is_direct = Buffers.isDirect(id);
        return drmModeCreatePropertyBlob1(fd, data, size, id_is_direct ? id : Buffers.getArray(id), id_is_direct ? Buffers.getDirectBufferByteOffset(id) : Buffers.getIndirectBufferByteOffset(id), id_is_direct);
  }

  /** Entry point to C language function: <code>int drmModeCreatePropertyBlob(int fd, const void *  data, size_t size, uint32_t *  id)</code><br>
      @param id a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeCreatePropertyBlob1(int fd, long data, long size, Object id, int id_byte_offset, boolean id_is_direct);

  /** Interface to C language function: <br> <code>int drmModeCreatePropertyBlob(int fd, const void *  data, size_t size, uint32_t *  id)</code><br>   */
  public static int drmModeCreatePropertyBlob(int fd, long data, long size, int[] id, int id_offset)  {

    if(id != null && id.length <= id_offset)
      throw new RuntimeException("array offset argument \"id_offset\" (" + id_offset + ") equals or exceeds array length (" + id.length + ")");
        return drmModeCreatePropertyBlob1(fd, data, size, id, Buffers.SIZEOF_INT * id_offset, false);
  }

  /** Interface to C language function: <br> <code>int drmModeDestroyPropertyBlob(int fd, uint32_t id)</code><br>   */
  public static native int drmModeDestroyPropertyBlob(int fd, int id);

  /** Interface to C language function: <br> <code>int drmModeCreateLease(int fd, const uint32_t *  objects, int num_objects, int flags, uint32_t *  lessee_id)</code><br>
      @param objects a direct or array-backed {@link java.nio.IntBuffer}
      @param lessee_id a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int drmModeCreateLease(int fd, IntBuffer objects, int num_objects, int flags, IntBuffer lessee_id)  {

    final boolean objects_is_direct = Buffers.isDirect(objects);
    final boolean lessee_id_is_direct = Buffers.isDirect(lessee_id);
        return drmModeCreateLease1(fd, objects_is_direct ? objects : Buffers.getArray(objects), objects_is_direct ? Buffers.getDirectBufferByteOffset(objects) : Buffers.getIndirectBufferByteOffset(objects), objects_is_direct, num_objects, flags, lessee_id_is_direct ? lessee_id : Buffers.getArray(lessee_id), lessee_id_is_direct ? Buffers.getDirectBufferByteOffset(lessee_id) : Buffers.getIndirectBufferByteOffset(lessee_id), lessee_id_is_direct);
  }

  /** Entry point to C language function: <code>int drmModeCreateLease(int fd, const uint32_t *  objects, int num_objects, int flags, uint32_t *  lessee_id)</code><br>
      @param objects a direct or array-backed {@link java.nio.IntBuffer}
      @param lessee_id a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int drmModeCreateLease1(int fd, Object objects, int objects_byte_offset, boolean objects_is_direct, int num_objects, int flags, Object lessee_id, int lessee_id_byte_offset, boolean lessee_id_is_direct);

  /** Interface to C language function: <br> <code>int drmModeCreateLease(int fd, const uint32_t *  objects, int num_objects, int flags, uint32_t *  lessee_id)</code><br>   */
  public static int drmModeCreateLease(int fd, int[] objects, int objects_offset, int num_objects, int flags, int[] lessee_id, int lessee_id_offset)  {

    if(objects != null && objects.length <= objects_offset)
      throw new RuntimeException("array offset argument \"objects_offset\" (" + objects_offset + ") equals or exceeds array length (" + objects.length + ")");
    if(lessee_id != null && lessee_id.length <= lessee_id_offset)
      throw new RuntimeException("array offset argument \"lessee_id_offset\" (" + lessee_id_offset + ") equals or exceeds array length (" + lessee_id.length + ")");
        return drmModeCreateLease1(fd, objects, Buffers.SIZEOF_INT * objects_offset, false, num_objects, flags, lessee_id, Buffers.SIZEOF_INT * lessee_id_offset, false);
  }

  /** Interface to C language function: <br> <code>int drmModeRevokeLease(int fd, uint32_t lessee_id)</code><br>   */
  public static native int drmModeRevokeLease(int fd, int lessee_id);

  /** Interface to C language function: <br> <code>int gbm_device_get_fd(struct gbm_device *  gbm)</code><br>   */
  public static native int gbm_device_get_fd(long gbm);

  /** Interface to C language function: <br> <code>const char *  gbm_device_get_backend_name(struct gbm_device *  gbm)</code><br>   */
  public static ByteBuffer gbm_device_get_backend_name(long gbm)  {

    final ByteBuffer _res;
    _res = gbm_device_get_backend_name1(gbm);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code>const char *  gbm_device_get_backend_name(struct gbm_device *  gbm)</code><br>   */
  private static native ByteBuffer gbm_device_get_backend_name1(long gbm);

  /** Interface to C language function: <br> <code>int gbm_device_is_format_supported(struct gbm_device *  gbm, uint32_t format, uint32_t usage)</code><br>   */
  public static native int gbm_device_is_format_supported(long gbm, int format, int usage);

  /** Interface to C language function: <br> <code>int gbm_device_get_format_modifier_plane_count(struct gbm_device *  gbm, uint32_t format, uint64_t modifier)</code><br>   */
  public static native int gbm_device_get_format_modifier_plane_count(long gbm, int format, long modifier);

  /** Interface to C language function: <br> <code>void gbm_device_destroy(struct gbm_device *  gbm)</code><br>   */
  public static native void gbm_device_destroy(long gbm);

  /** Interface to C language function: <br> <code>struct gbm_device *  gbm_create_device(int fd)</code><br>   */
  public static native long gbm_create_device(int fd);

  /** Interface to C language function: <br> <code>struct gbm_bo *  gbm_bo_create(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, uint32_t flags)</code><br>   */
  public static native long gbm_bo_create(long gbm, int width, int height, int format, int flags);

  /** Interface to C language function: <br> <code>struct gbm_bo *  gbm_bo_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>
      @param modifiers a direct or array-backed {@link java.nio.LongBuffer}   */
  public static long gbm_bo_create_with_modifiers(long gbm, int width, int height, int format, LongBuffer modifiers, int count)  {

    final boolean modifiers_is_direct = Buffers.isDirect(modifiers);
        return gbm_bo_create_with_modifiers1(gbm, width, height, format, modifiers_is_direct ? modifiers : Buffers.getArray(modifiers), modifiers_is_direct ? Buffers.getDirectBufferByteOffset(modifiers) : Buffers.getIndirectBufferByteOffset(modifiers), modifiers_is_direct, count);
  }

  /** Entry point to C language function: <code>struct gbm_bo *  gbm_bo_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>
      @param modifiers a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native long gbm_bo_create_with_modifiers1(long gbm, int width, int height, int format, Object modifiers, int modifiers_byte_offset, boolean modifiers_is_direct, int count);

  /** Interface to C language function: <br> <code>struct gbm_bo *  gbm_bo_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>   */
  public static long gbm_bo_create_with_modifiers(long gbm, int width, int height, int format, long[] modifiers, int modifiers_offset, int count)  {

    if(modifiers != null && modifiers.length <= modifiers_offset)
      throw new RuntimeException("array offset argument \"modifiers_offset\" (" + modifiers_offset + ") equals or exceeds array length (" + modifiers.length + ")");
        return gbm_bo_create_with_modifiers1(gbm, width, height, format, modifiers, Buffers.SIZEOF_LONG * modifiers_offset, false, count);
  }

  /** Interface to C language function: <br> <code>struct gbm_bo *  gbm_bo_import(struct gbm_device *  gbm, uint32_t type, void *  buffer, uint32_t usage)</code><br>   */
  public static native long gbm_bo_import(long gbm, int type, long buffer, int usage);

  /** Interface to C language function: <br> <code>void *  gbm_bo_map(struct gbm_bo *  bo, uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t flags, uint32_t *  stride, void *  *  map_data)</code><br>
      @param stride a direct or array-backed {@link java.nio.IntBuffer}
      @param map_data a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long gbm_bo_map(long bo, int x, int y, int width, int height, int flags, IntBuffer stride, PointerBuffer map_data)  {

    final boolean stride_is_direct = Buffers.isDirect(stride);
    final boolean map_data_is_direct = Buffers.isDirect(map_data);
        return gbm_bo_map1(bo, x, y, width, height, flags, stride_is_direct ? stride : Buffers.getArray(stride), stride_is_direct ? Buffers.getDirectBufferByteOffset(stride) : Buffers.getIndirectBufferByteOffset(stride), stride_is_direct, map_data_is_direct ? ( map_data != null ? map_data.getBuffer() : null ) : Buffers.getArray(map_data), map_data_is_direct ? Buffers.getDirectBufferByteOffset(map_data) : Buffers.getIndirectBufferByteOffset(map_data), map_data_is_direct);
  }

  /** Entry point to C language function: <code>void *  gbm_bo_map(struct gbm_bo *  bo, uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t flags, uint32_t *  stride, void *  *  map_data)</code><br>
      @param stride a direct or array-backed {@link java.nio.IntBuffer}
      @param map_data a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long gbm_bo_map1(long bo, int x, int y, int width, int height, int flags, Object stride, int stride_byte_offset, boolean stride_is_direct, Object map_data, int map_data_byte_offset, boolean map_data_is_direct);

  /** Interface to C language function: <br> <code>void *  gbm_bo_map(struct gbm_bo *  bo, uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t flags, uint32_t *  stride, void *  *  map_data)</code><br>
      @param map_data a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long gbm_bo_map(long bo, int x, int y, int width, int height, int flags, int[] stride, int stride_offset, PointerBuffer map_data)  {

    if(stride != null && stride.length <= stride_offset)
      throw new RuntimeException("array offset argument \"stride_offset\" (" + stride_offset + ") equals or exceeds array length (" + stride.length + ")");
    final boolean map_data_is_direct = Buffers.isDirect(map_data);
        return gbm_bo_map1(bo, x, y, width, height, flags, stride, Buffers.SIZEOF_INT * stride_offset, false, map_data_is_direct ? ( map_data != null ? map_data.getBuffer() : null ) : Buffers.getArray(map_data), map_data_is_direct ? Buffers.getDirectBufferByteOffset(map_data) : Buffers.getIndirectBufferByteOffset(map_data), map_data_is_direct);
  }

  /** Interface to C language function: <br> <code>void gbm_bo_unmap(struct gbm_bo *  bo, void *  map_data)</code><br>   */
  public static native void gbm_bo_unmap(long bo, long map_data);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_width(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_width(long bo);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_height(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_height(long bo);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_stride(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_stride(long bo);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_stride_for_plane(struct gbm_bo *  bo, int plane)</code><br>   */
  public static native int gbm_bo_get_stride_for_plane(long bo, int plane);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_format(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_format(long bo);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_bpp(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_bpp(long bo);

  /** Interface to C language function: <br> <code>uint32_t gbm_bo_get_offset(struct gbm_bo *  bo, int plane)</code><br>   */
  public static native int gbm_bo_get_offset(long bo, int plane);

  /** Interface to C language function: <br> <code>struct gbm_device *  gbm_bo_get_device(struct gbm_bo *  bo)</code><br>   */
  public static native long gbm_bo_get_device(long bo);

  /** Interface to C language function: <br> <code>int gbm_bo_get_fd(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_fd(long bo);

  /** Interface to C language function: <br> <code>uint64_t gbm_bo_get_modifier(struct gbm_bo *  bo)</code><br>   */
  public static native long gbm_bo_get_modifier(long bo);

  /** Interface to C language function: <br> <code>int gbm_bo_get_plane_count(struct gbm_bo *  bo)</code><br>   */
  public static native int gbm_bo_get_plane_count(long bo);

  /** Interface to C language function: <br> <code>int gbm_bo_write(struct gbm_bo *  bo, const void *  buf, size_t count)</code><br>   */
  public static native int gbm_bo_write(long bo, long buf, long count);

  /** Interface to C language function: <br> <code>void *  gbm_bo_get_user_data(struct gbm_bo *  bo)</code><br>   */
  public static native long gbm_bo_get_user_data(long bo);

  /** Interface to C language function: <br> <code>void gbm_bo_destroy(struct gbm_bo *  bo)</code><br>   */
  public static native void gbm_bo_destroy(long bo);

  /** Interface to C language function: <br> <code>struct gbm_surface *  gbm_surface_create(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, uint32_t flags)</code><br>   */
  public static native long gbm_surface_create(long gbm, int width, int height, int format, int flags);

  /** Interface to C language function: <br> <code>struct gbm_surface *  gbm_surface_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>
      @param modifiers a direct or array-backed {@link java.nio.LongBuffer}   */
  public static long gbm_surface_create_with_modifiers(long gbm, int width, int height, int format, LongBuffer modifiers, int count)  {

    final boolean modifiers_is_direct = Buffers.isDirect(modifiers);
        return gbm_surface_create_with_modifiers1(gbm, width, height, format, modifiers_is_direct ? modifiers : Buffers.getArray(modifiers), modifiers_is_direct ? Buffers.getDirectBufferByteOffset(modifiers) : Buffers.getIndirectBufferByteOffset(modifiers), modifiers_is_direct, count);
  }

  /** Entry point to C language function: <code>struct gbm_surface *  gbm_surface_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>
      @param modifiers a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native long gbm_surface_create_with_modifiers1(long gbm, int width, int height, int format, Object modifiers, int modifiers_byte_offset, boolean modifiers_is_direct, int count);

  /** Interface to C language function: <br> <code>struct gbm_surface *  gbm_surface_create_with_modifiers(struct gbm_device *  gbm, uint32_t width, uint32_t height, uint32_t format, const uint64_t *  modifiers, unsigned const int count)</code><br>   */
  public static long gbm_surface_create_with_modifiers(long gbm, int width, int height, int format, long[] modifiers, int modifiers_offset, int count)  {

    if(modifiers != null && modifiers.length <= modifiers_offset)
      throw new RuntimeException("array offset argument \"modifiers_offset\" (" + modifiers_offset + ") equals or exceeds array length (" + modifiers.length + ")");
        return gbm_surface_create_with_modifiers1(gbm, width, height, format, modifiers, Buffers.SIZEOF_LONG * modifiers_offset, false, count);
  }

  /** Interface to C language function: <br> <code>struct gbm_bo *  gbm_surface_lock_front_buffer(struct gbm_surface *  surface)</code><br>   */
  public static native long gbm_surface_lock_front_buffer(long surface);

  /** Interface to C language function: <br> <code>void gbm_surface_release_buffer(struct gbm_surface *  surface, struct gbm_bo *  bo)</code><br>   */
  public static native void gbm_surface_release_buffer(long surface, long bo);

  /** Interface to C language function: <br> <code>int gbm_surface_has_free_buffers(struct gbm_surface *  surface)</code><br>   */
  public static native int gbm_surface_has_free_buffers(long surface);

  /** Interface to C language function: <br> <code>void gbm_surface_destroy(struct gbm_surface *  surface)</code><br>   */
  public static native void gbm_surface_destroy(long surface);


  // --- Begin CustomJavaCode .cfg declarations
 public static native int drmOpenFile(String filename);
  // ---- End CustomJavaCode .cfg declarations
} // end of class DRMLib
